{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sistemas Hardware-Software \u00b6 Bem vindo ao curso de Sistemas Hardware-Software 2020/2. Professor : Igor Montagner Avalia\u00e7\u00e3o \u00b6 A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; Os Laborat\u00f3rios ser\u00e3o disponibilizados neste site e dever\u00e3o ser entregues no reposit\u00f3rio de atividades da disciplina. A m\u00e9dia final \u00e9 dada por 10% Atividades 40% Laborat\u00f3rios 50% m\u00e9dia de Provas Condi\u00e7\u00f5es de barreira M\u00e9dia de provas >= 4,5 PI, PF >= 4,0 Laborat\u00f3rios >= 5 Caso estas condi\u00e7\u00f5es n\u00e3o sejam cumpridas ver detalhes na aula 01 Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.","title":"Home"},{"location":"#sistemas-hardware-software","text":"Bem vindo ao curso de Sistemas Hardware-Software 2020/2. Professor : Igor Montagner","title":"Sistemas Hardware-Software"},{"location":"#avaliacao","text":"A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos: Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova; Os Laborat\u00f3rios ser\u00e3o disponibilizados neste site e dever\u00e3o ser entregues no reposit\u00f3rio de atividades da disciplina. A m\u00e9dia final \u00e9 dada por 10% Atividades 40% Laborat\u00f3rios 50% m\u00e9dia de Provas Condi\u00e7\u00f5es de barreira M\u00e9dia de provas >= 4,5 PI, PF >= 4,0 Laborat\u00f3rios >= 5 Caso estas condi\u00e7\u00f5es n\u00e3o sejam cumpridas ver detalhes na aula 01 Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.","title":"Avalia\u00e7\u00e3o"},{"location":"sobre/","text":"Plano de aulas \u00b6 SEG 13:30 - 15:40 QUI 15:45 - 17:45 Atendimento: QUI 14:00 - 15:30 Plano de aulas Data Quest\u00e3o/Problema Conte\u00fado/Atividade 24/08 Mutir\u00e3o C Exerc\u00edcios pr\u00e1ticos de revis\u00e3o 27/08 Mutir\u00e3o C Exerc\u00edcios pr\u00e1ticos de revis\u00e3o 31/08 Como a CPU representa dados em baixo n\u00edvel? Representa\u00e7\u00e3o de inteiros na CPU: n\u00fameros bin\u00e1rios e hexadecimais, complemento de dois, opera\u00e7\u00f5es bit a bit. Leitura: Cap 2 CS:APP; Cap 9 Stallings 03/09 Como a CPU representa dados em baixo n\u00edvel? Representa\u00e7\u00e3o de ponteiros, arrays e estruturas em RAM. Leitura: Cap 2 CS:APP; Cap 9 Stallings 07/09 FERIADO FERIADO 10/09 Como a CPU representa e executa um programa escrito em C? Arquitetura de computadores: registradores, mem\u00f3ria e endere\u00e7amento Assembly: Organiza\u00e7\u00e3o de um execut\u00e1vel no disco e na mem\u00f3ria Leitura: Cap 3.1 \u2013 3.4 CS:APP 14/09 Como a CPU representa e executa um programa escrito em C? Arquitetura de computadores: chamadas de fun\u00e7\u00e3o e pilha Assembly: Exerc\u00edcios com chamadas de fun\u00e7\u00e3o e opera\u00e7\u00f5es com inteiros Leitura: Cap 3.5 CS:APP 17/09 Como a CPU representa e executa um programa escrito em C? Assembly: express\u00f5es booleanas e estruturas de controle condicionais 21/09 Como a CPU representa e executa um programa escrito em C? Assembly: estruturas de controle de loop Leitura: Cap 3.6 CS:APP 24/09 Como a CPU representa e executa um programa escrito em C? Revis\u00e3o; organiza\u00e7\u00e3o de execut\u00e1vel no disco e na mem\u00f3ria Assembly: vari\u00e1veis locais, strings e arrays Leitura: Cap 3.7 \u2013 3.8 CS:APP 28/09 Como a CPU representa e executa um programa escrito em C? Exerc\u00edcios pr\u00e1ticos de revis\u00e3o 01/10 E se meu programa precisar de mais mem\u00f3ria? A fun\u00e7\u00e3o malloc e a aloca\u00e7\u00e3o din\u00e2mica de estruturas, arrays e strings. Uso da ferramenta valgrind para checagem de mem\u00f3ria Leituras: Cap 16 Kochan (Prog in C); Cap 9.9 CS:APP 05/10 E se meu programa precisar de mais mem\u00f3ria? Tipos Abstratos de dados e aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria Leituras: Cap 6 K&R 08/10 PROVA INTERMEDI\u00c1RIA PROVA INTERMEDI\u00c1RIA 12/10 FERIADO FERIADO 15/10 O que \u00e9 um sistema operacional? Como os programas se comunicam com ele? Vis\u00e3o global de um sistema: kernel, sistema de arquivos, biblioteca padr\u00e3o e bootloaders Leitura: Cap 10.2 Tanenbaum; Kivity et al 2014. 19/10 Como tudo isto est\u00e1 organizado em um sistema operacional? Aula est\u00fadio para projeto: Linux do Zero 22/10 Como tudo isto est\u00e1 organizado em um sistema operacional? Aula est\u00fadio para projeto: Linux do Zero 26/10 O que \u00e9 um sistema operacional? Como os programas se comunicam com ele? Sistemas operacionais: processos. Explorando chamadas de sistemas para entrada/sa\u00edda Leitura: Cap 8 CS:APP, 29/10 O que \u00e9 um sistema operacional? Como os programas se comunicam com ele? Sistemas operacionais: processos. Explorando chamadas de sistemas para cria\u00e7\u00e3o de processo (fork) e espera de seus resultados (wait). Leitura: Cap 8 CS:APP, Leitura complementar sobre escalonamento de processos: Cap 5 Silberschats 02/11 FERIADO PROVA INTERMEDI\u00c1RIA 05/11 O que \u00e9 um sistema operacional? Como os programas se comunicam com ele? Sistemas operacionais: processos. Explorando chamadas de sistemas para execu\u00e7\u00e3o de programas (exec) Leitura: Cap 8 CS:APP, 09/11 E se o SO quiser avisar um processo que algo ocorreu? Sinais: conceitos, captura e bloqueio. Introdu\u00e7\u00e3o \u00e0 ideia de concorr\u00eancia 12/11 E se o SO quiser avisar um processo que algo ocorreu? Captura e bloqueio de sinais: teoria e exerc\u00edcios pr\u00e1ticos 16/11 Como envio informa\u00e7\u00f5es entre processos? Entrada e sa\u00edda padr\u00e3o, chamadas de sistema pipe, dup2 para redirecionamento de arquivos. 19/11 \u00c9 poss\u00edvel dividir o trabalho em partes que executem ao mesmo tempo? Introdu\u00e7\u00e3o ao conceito de threads e sua utiliza\u00e7\u00e3o Cria\u00e7\u00e3o de threads usando pthreads. Leitura: Cap 12 CS:APP 23/11 \u00c9 poss\u00edvel dividir o trabalho em partes que executem ao mesmo tempo? Tarefas IO- e CPU-bound. Sincroniza\u00e7\u00e3o usando sem\u00e1foros. Leitura: Cap 12 CS:APP 26/11 PROVA FINAL PROVA FINAL 30/11 PROVA FINAL PROVA FINAL 03/12 nan nan 07/12 PROVA SUB PROVA SUB","title":"Burocracias"},{"location":"sobre/#plano-de-aulas","text":"SEG 13:30 - 15:40 QUI 15:45 - 17:45 Atendimento: QUI 14:00 - 15:30 Plano de aulas Data Quest\u00e3o/Problema Conte\u00fado/Atividade 24/08 Mutir\u00e3o C Exerc\u00edcios pr\u00e1ticos de revis\u00e3o 27/08 Mutir\u00e3o C Exerc\u00edcios pr\u00e1ticos de revis\u00e3o 31/08 Como a CPU representa dados em baixo n\u00edvel? Representa\u00e7\u00e3o de inteiros na CPU: n\u00fameros bin\u00e1rios e hexadecimais, complemento de dois, opera\u00e7\u00f5es bit a bit. Leitura: Cap 2 CS:APP; Cap 9 Stallings 03/09 Como a CPU representa dados em baixo n\u00edvel? Representa\u00e7\u00e3o de ponteiros, arrays e estruturas em RAM. Leitura: Cap 2 CS:APP; Cap 9 Stallings 07/09 FERIADO FERIADO 10/09 Como a CPU representa e executa um programa escrito em C? Arquitetura de computadores: registradores, mem\u00f3ria e endere\u00e7amento Assembly: Organiza\u00e7\u00e3o de um execut\u00e1vel no disco e na mem\u00f3ria Leitura: Cap 3.1 \u2013 3.4 CS:APP 14/09 Como a CPU representa e executa um programa escrito em C? Arquitetura de computadores: chamadas de fun\u00e7\u00e3o e pilha Assembly: Exerc\u00edcios com chamadas de fun\u00e7\u00e3o e opera\u00e7\u00f5es com inteiros Leitura: Cap 3.5 CS:APP 17/09 Como a CPU representa e executa um programa escrito em C? Assembly: express\u00f5es booleanas e estruturas de controle condicionais 21/09 Como a CPU representa e executa um programa escrito em C? Assembly: estruturas de controle de loop Leitura: Cap 3.6 CS:APP 24/09 Como a CPU representa e executa um programa escrito em C? Revis\u00e3o; organiza\u00e7\u00e3o de execut\u00e1vel no disco e na mem\u00f3ria Assembly: vari\u00e1veis locais, strings e arrays Leitura: Cap 3.7 \u2013 3.8 CS:APP 28/09 Como a CPU representa e executa um programa escrito em C? Exerc\u00edcios pr\u00e1ticos de revis\u00e3o 01/10 E se meu programa precisar de mais mem\u00f3ria? A fun\u00e7\u00e3o malloc e a aloca\u00e7\u00e3o din\u00e2mica de estruturas, arrays e strings. Uso da ferramenta valgrind para checagem de mem\u00f3ria Leituras: Cap 16 Kochan (Prog in C); Cap 9.9 CS:APP 05/10 E se meu programa precisar de mais mem\u00f3ria? Tipos Abstratos de dados e aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria Leituras: Cap 6 K&R 08/10 PROVA INTERMEDI\u00c1RIA PROVA INTERMEDI\u00c1RIA 12/10 FERIADO FERIADO 15/10 O que \u00e9 um sistema operacional? Como os programas se comunicam com ele? Vis\u00e3o global de um sistema: kernel, sistema de arquivos, biblioteca padr\u00e3o e bootloaders Leitura: Cap 10.2 Tanenbaum; Kivity et al 2014. 19/10 Como tudo isto est\u00e1 organizado em um sistema operacional? Aula est\u00fadio para projeto: Linux do Zero 22/10 Como tudo isto est\u00e1 organizado em um sistema operacional? Aula est\u00fadio para projeto: Linux do Zero 26/10 O que \u00e9 um sistema operacional? Como os programas se comunicam com ele? Sistemas operacionais: processos. Explorando chamadas de sistemas para entrada/sa\u00edda Leitura: Cap 8 CS:APP, 29/10 O que \u00e9 um sistema operacional? Como os programas se comunicam com ele? Sistemas operacionais: processos. Explorando chamadas de sistemas para cria\u00e7\u00e3o de processo (fork) e espera de seus resultados (wait). Leitura: Cap 8 CS:APP, Leitura complementar sobre escalonamento de processos: Cap 5 Silberschats 02/11 FERIADO PROVA INTERMEDI\u00c1RIA 05/11 O que \u00e9 um sistema operacional? Como os programas se comunicam com ele? Sistemas operacionais: processos. Explorando chamadas de sistemas para execu\u00e7\u00e3o de programas (exec) Leitura: Cap 8 CS:APP, 09/11 E se o SO quiser avisar um processo que algo ocorreu? Sinais: conceitos, captura e bloqueio. Introdu\u00e7\u00e3o \u00e0 ideia de concorr\u00eancia 12/11 E se o SO quiser avisar um processo que algo ocorreu? Captura e bloqueio de sinais: teoria e exerc\u00edcios pr\u00e1ticos 16/11 Como envio informa\u00e7\u00f5es entre processos? Entrada e sa\u00edda padr\u00e3o, chamadas de sistema pipe, dup2 para redirecionamento de arquivos. 19/11 \u00c9 poss\u00edvel dividir o trabalho em partes que executem ao mesmo tempo? Introdu\u00e7\u00e3o ao conceito de threads e sua utiliza\u00e7\u00e3o Cria\u00e7\u00e3o de threads usando pthreads. Leitura: Cap 12 CS:APP 23/11 \u00c9 poss\u00edvel dividir o trabalho em partes que executem ao mesmo tempo? Tarefas IO- e CPU-bound. Sincroniza\u00e7\u00e3o usando sem\u00e1foros. Leitura: Cap 12 CS:APP 26/11 PROVA FINAL PROVA FINAL 30/11 PROVA FINAL PROVA FINAL 03/12 nan nan 07/12 PROVA SUB PROVA SUB","title":"Plano de aulas"},{"location":"aulas/99-corretor-automatico/","text":"99 - Corretor Autom\u00e1tico \u00b6 Algumas atividades de sala de aula entrar\u00e3o na nota final. Elas est\u00e3o marcadas como Entrega no in\u00edcio e ser\u00e3o entregues via um reposit\u00f3rio especial no Github. Preencha a pesquisa de usu\u00e1rios do Github Voc\u00ea receber\u00e1 um convite para reposit\u00f3rio. Todas as atividades ser\u00e3o disponibilizadas neste reposit\u00f3rio e suas solu\u00e7\u00f5es devem ser adicionadas nos arquivos correspondentes. O corretor autom\u00e1tico depende do pacote grading-tools , que dever\u00e1 ser instalado como abaixo. $> python3.8 -m pip install --user git+https://github.com/igordsm/grading-tools Python 3.8 no Ubuntu Se seu python3 \u00e9 uma vers\u00e3o inferior ao 3.8, voc\u00ea pode instal\u00e1-lo com os pacotes abaixo: python3.8 python3.8-dev A partir da\u00ed poder\u00e1 seguir normalmente as instru\u00e7\u00f5es desta p\u00e1gina. Com isso configurado, \u00e9 s\u00f3 compilar seu programa e rodar python3.8 corretor.py executavel . Para baixar os novos exerc\u00edcios \u00e9 s\u00f3 rodar git pull . Os exerc\u00edcios ser\u00e3o entregues criando um commit com sua resposta e dando git push . Warning Fique atento a atualiza\u00e7\u00f5es no seu reposit\u00f3rio de atividades. Todo novo exerc\u00edcio para entrega disponibilizado nos handouts devera aparecer no seu reposit\u00f3rio tamb\u00e9m. Ser\u00e1 avisado em aula se for necess\u00e1rio atualizar tamb\u00e9m o pacote acima.","title":"99 - Corretor Autom\u00e1tico"},{"location":"aulas/99-corretor-automatico/#99-corretor-automatico","text":"Algumas atividades de sala de aula entrar\u00e3o na nota final. Elas est\u00e3o marcadas como Entrega no in\u00edcio e ser\u00e3o entregues via um reposit\u00f3rio especial no Github. Preencha a pesquisa de usu\u00e1rios do Github Voc\u00ea receber\u00e1 um convite para reposit\u00f3rio. Todas as atividades ser\u00e3o disponibilizadas neste reposit\u00f3rio e suas solu\u00e7\u00f5es devem ser adicionadas nos arquivos correspondentes. O corretor autom\u00e1tico depende do pacote grading-tools , que dever\u00e1 ser instalado como abaixo. $> python3.8 -m pip install --user git+https://github.com/igordsm/grading-tools Python 3.8 no Ubuntu Se seu python3 \u00e9 uma vers\u00e3o inferior ao 3.8, voc\u00ea pode instal\u00e1-lo com os pacotes abaixo: python3.8 python3.8-dev A partir da\u00ed poder\u00e1 seguir normalmente as instru\u00e7\u00f5es desta p\u00e1gina. Com isso configurado, \u00e9 s\u00f3 compilar seu programa e rodar python3.8 corretor.py executavel . Para baixar os novos exerc\u00edcios \u00e9 s\u00f3 rodar git pull . Os exerc\u00edcios ser\u00e3o entregues criando um commit com sua resposta e dando git push . Warning Fique atento a atualiza\u00e7\u00f5es no seu reposit\u00f3rio de atividades. Todo novo exerc\u00edcio para entrega disponibilizado nos handouts devera aparecer no seu reposit\u00f3rio tamb\u00e9m. Ser\u00e1 avisado em aula se for necess\u00e1rio atualizar tamb\u00e9m o pacote acima.","title":"99 - Corretor Autom\u00e1tico"},{"location":"aulas/01-introducao/","text":"01 e 02 - Exerc\u00edcios de C \u00b6 O in\u00edcio do nosso curso ser\u00e1 uma revis\u00e3o de programa\u00e7\u00e3o em C . Flu\u00eancia nessa linguagem \u00e9 importante tanto para a primeira parte, em que examinamos como c\u00f3digo \u00e9 transformado em instru\u00e7\u00f5es de m\u00e1quina, quanto na segunda, em que usamos C para interagir com o sistema operacional. Importante Os exerc\u00edcios desta p\u00e1gina s\u00e3o complementares ao material do Mutir\u00e3o C . Pode ser uma boa revisitar o material do semestre passado para se recordar da estrutura b\u00e1sica de um programa em C e para as explica\u00e7\u00f5es detalhadas de cada funcionalidade usada nos exerc\u00edcios. Os exerc\u00edcios para entrega nesta p\u00e1gina contar\u00e3o na nota de atividades assim como os do restante do curso. Example Fa\u00e7a um programa que receba dois inteiros e mostre sua divis\u00e3o inteira, seu resto e sua divis\u00e3o fracion\u00e1ria (com at\u00e9 4 casas decimais). Se o segundo n\u00famero for 0, seu programa dever\u00e1 mostrar tr\u00eas 0 na sa\u00edda. Entrada 2 3 Sa\u00edda 0 2 0.6667 Example Fa\u00e7a um programa que mostra os d\u00edgitos de um n\u00famero ao contr\u00e1rio. Dica : use o operador resto da divis\u00e3o % . Entrada 123456 Sa\u00edda 6 5 4 3 2 1 Example Fa\u00e7a um programa que l\u00ea um inteiro n e depois n inteiros e computa sua m\u00e9dia. Entrada 4 1 2 3 4 Sa\u00edda 2.5 Example Entrega : Fa\u00e7a um programa que l\u00ea um inteiro n e mostre os n primeiros n\u00fameros da tabuada para todos os n\u00fameros entre 2 e n . Entrada 4 Sa\u00edda 2 4 6 8 3 6 9 12 4 8 12 16 Example Fa\u00e7a um programa que l\u00ea tr\u00eas inteiros n , d1 e d2 e imprime todos os inteiros entre 2 e n que s\u00e3o divis\u00edveis ao mesmo tempo por d1 e d2 . Entrada 15 3 2 Sa\u00edda 6 12 Example Fa\u00e7a um programa que l\u00ea at\u00e9 100 inteiros e os guarda em um vetor global nums . Voc\u00ea deve parar de ler inteiros ao receber um inteiro negativo, que n\u00e3o dever\u00e1 ser guardado. Depois de armazen\u00e1-los, leia um um n\u00famero d e imprima na tela quantos n\u00fameros lidos s\u00e3o maiores que d . Entrada : 1 2 3 4 -1 3 Sa\u00edda 1 Example Fa\u00e7a um programa que l\u00ea uma linha de texto e mostra no terminal seu tamanho. Entrada : abcdefgh Sa\u00edda 8 Example Fa\u00e7a um programa que l\u00ea uma linha de texto e conta quantas palavras tem na linha. Todo caractere n\u00e3o alfanum\u00e9rico divide uma palavra. Veja o exemplo abaixo. Entrada : palavra dois tres,quatro1continua. Cinco 3seis#sete Sa\u00edda 7 Example Entrega : Fa\u00e7a uma fun\u00e7\u00e3o que determina se uma string \u00e9 igual se lida de tr\u00e1s para frente. Voc\u00ea dever\u00e1 ignorar todos os caracteres n\u00e3o alfanum\u00e9ricos. Dica : Se necess\u00e1rio, consulte novamente a se\u00e7ao de Strings do Mutir\u00e3o. Como voc\u00ea checaria todos os caracteres entre '0' e '9'? E para as letras mai\u00fasculas e min\u00fasculas? Voc\u00ea pode precisar consultar a Tabela ASCII para entender melhor como fazer isso. Entrada : igual a laugi Sa\u00edda SIM Example Fa\u00e7a um programa que l\u00ea dois inteiros m < 100 e n < 100 . Ent\u00e3o seu programa dever\u00e1 ler uma matriz de m linhas por n colunas e mostrar no terminal o \u00edndice do maior valor de cada coluna. Declare sua matriz como vari\u00e1vel global. Iremos aprender como alocar matrizes de tamanho arbitr\u00e1rio no curso. Entrada : 3 4 1 2 5.8 6 3 6 9 8 5 2 3 2.0 Sa\u00edda 2 1 1 0 Example Entrega : Fa\u00e7a um programa que encontra \"vales\" em uma matriz. Uma posi\u00e7\u00e3o i,j \u00e9 um vale se todos os seus vizinhos diretos s\u00e3o maiores que ele. Considere que todas as posi\u00e7\u00f5es fora da matriz tem valor 0. Entrada : 5 5 1 1 2 4 7 4 5 -1 -2 8 1 1 1 1 2 4 5 0 6 10 4 4 4 4 4 Sa\u00edda 1 3 3 2","title":"01 e 02 - Exerc\u00edcios de C"},{"location":"aulas/01-introducao/#01-e-02-exercicios-de-c","text":"O in\u00edcio do nosso curso ser\u00e1 uma revis\u00e3o de programa\u00e7\u00e3o em C . Flu\u00eancia nessa linguagem \u00e9 importante tanto para a primeira parte, em que examinamos como c\u00f3digo \u00e9 transformado em instru\u00e7\u00f5es de m\u00e1quina, quanto na segunda, em que usamos C para interagir com o sistema operacional. Importante Os exerc\u00edcios desta p\u00e1gina s\u00e3o complementares ao material do Mutir\u00e3o C . Pode ser uma boa revisitar o material do semestre passado para se recordar da estrutura b\u00e1sica de um programa em C e para as explica\u00e7\u00f5es detalhadas de cada funcionalidade usada nos exerc\u00edcios. Os exerc\u00edcios para entrega nesta p\u00e1gina contar\u00e3o na nota de atividades assim como os do restante do curso. Example Fa\u00e7a um programa que receba dois inteiros e mostre sua divis\u00e3o inteira, seu resto e sua divis\u00e3o fracion\u00e1ria (com at\u00e9 4 casas decimais). Se o segundo n\u00famero for 0, seu programa dever\u00e1 mostrar tr\u00eas 0 na sa\u00edda. Entrada 2 3 Sa\u00edda 0 2 0.6667 Example Fa\u00e7a um programa que mostra os d\u00edgitos de um n\u00famero ao contr\u00e1rio. Dica : use o operador resto da divis\u00e3o % . Entrada 123456 Sa\u00edda 6 5 4 3 2 1 Example Fa\u00e7a um programa que l\u00ea um inteiro n e depois n inteiros e computa sua m\u00e9dia. Entrada 4 1 2 3 4 Sa\u00edda 2.5 Example Entrega : Fa\u00e7a um programa que l\u00ea um inteiro n e mostre os n primeiros n\u00fameros da tabuada para todos os n\u00fameros entre 2 e n . Entrada 4 Sa\u00edda 2 4 6 8 3 6 9 12 4 8 12 16 Example Fa\u00e7a um programa que l\u00ea tr\u00eas inteiros n , d1 e d2 e imprime todos os inteiros entre 2 e n que s\u00e3o divis\u00edveis ao mesmo tempo por d1 e d2 . Entrada 15 3 2 Sa\u00edda 6 12 Example Fa\u00e7a um programa que l\u00ea at\u00e9 100 inteiros e os guarda em um vetor global nums . Voc\u00ea deve parar de ler inteiros ao receber um inteiro negativo, que n\u00e3o dever\u00e1 ser guardado. Depois de armazen\u00e1-los, leia um um n\u00famero d e imprima na tela quantos n\u00fameros lidos s\u00e3o maiores que d . Entrada : 1 2 3 4 -1 3 Sa\u00edda 1 Example Fa\u00e7a um programa que l\u00ea uma linha de texto e mostra no terminal seu tamanho. Entrada : abcdefgh Sa\u00edda 8 Example Fa\u00e7a um programa que l\u00ea uma linha de texto e conta quantas palavras tem na linha. Todo caractere n\u00e3o alfanum\u00e9rico divide uma palavra. Veja o exemplo abaixo. Entrada : palavra dois tres,quatro1continua. Cinco 3seis#sete Sa\u00edda 7 Example Entrega : Fa\u00e7a uma fun\u00e7\u00e3o que determina se uma string \u00e9 igual se lida de tr\u00e1s para frente. Voc\u00ea dever\u00e1 ignorar todos os caracteres n\u00e3o alfanum\u00e9ricos. Dica : Se necess\u00e1rio, consulte novamente a se\u00e7ao de Strings do Mutir\u00e3o. Como voc\u00ea checaria todos os caracteres entre '0' e '9'? E para as letras mai\u00fasculas e min\u00fasculas? Voc\u00ea pode precisar consultar a Tabela ASCII para entender melhor como fazer isso. Entrada : igual a laugi Sa\u00edda SIM Example Fa\u00e7a um programa que l\u00ea dois inteiros m < 100 e n < 100 . Ent\u00e3o seu programa dever\u00e1 ler uma matriz de m linhas por n colunas e mostrar no terminal o \u00edndice do maior valor de cada coluna. Declare sua matriz como vari\u00e1vel global. Iremos aprender como alocar matrizes de tamanho arbitr\u00e1rio no curso. Entrada : 3 4 1 2 5.8 6 3 6 9 8 5 2 3 2.0 Sa\u00edda 2 1 1 0 Example Entrega : Fa\u00e7a um programa que encontra \"vales\" em uma matriz. Uma posi\u00e7\u00e3o i,j \u00e9 um vale se todos os seus vizinhos diretos s\u00e3o maiores que ele. Considere que todas as posi\u00e7\u00f5es fora da matriz tem valor 0. Entrada : 5 5 1 1 2 4 7 4 5 -1 -2 8 1 1 1 1 2 4 5 0 6 10 4 4 4 4 4 Sa\u00edda 1 3 3 2","title":"01 e 02 - Exerc\u00edcios de C"},{"location":"aulas/02-inteiros/","text":"02 - Inteiros na CPU \u00b6 Esta aula possui uma se\u00e7\u00e3o de exerc\u00edcios no reposit\u00f3rio de atividades: 04-inteiros .","title":"02 - Inteiros na CPU"},{"location":"aulas/02-inteiros/#02-inteiros-na-cpu","text":"Esta aula possui uma se\u00e7\u00e3o de exerc\u00edcios no reposit\u00f3rio de atividades: 04-inteiros .","title":"02 - Inteiros na CPU"},{"location":"aulas/03-ram/","text":"03 - Representa\u00e7\u00e3o de dados em RAM \u00b6 Experimentos \u00b6 Vamos trabalhar com os arquivos experimento0-4.c . Compile e execute cada um deles e coloque suas sa\u00eddas abaixo. Comente os resultados comparando os valores das constantes no c\u00f3digo em C e a sa\u00edda dos programas. Question Examine o c\u00f3digo C do arquivo experimento0.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento1.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento2.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento3.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento4.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Representa\u00e7\u00e3o de struct em RAM \u00b6 A utiliza\u00e7\u00e3o de struct junta tudo que j\u00e1 vimos sobre representa\u00e7\u00e3o de todos os tipos de dados na mem\u00f3ria. N\u00e3o se esque\u00e7a de levar em conta as quest\u00f5es de alinhamento mostradas na parte expositiva da aula. Warning Voc\u00ea n\u00e3o dever\u00e1 abrir o c\u00f3digo de parte1.c . Ele est\u00e1 no reposit\u00f3rio para voc\u00ea poder conferir suas respostas. Example A segunda parte da sa\u00edda de parte1 mostra os endere\u00e7os de cada campo do struct. Note que &one e &one.icon s\u00e3o iguais. Voc\u00ea consegue explicar por que? Se n\u00e3o, volte na aula expositiva e reveja a parte sobre struct e alinhamento de mem\u00f3ria. Example Os endere\u00e7os mostrados na sa\u00edda de parte1 pertencem a um s\u00f3 struct declarado como struct player one . Quais s\u00e3o os tamanhos de cada campo? Dica : pode n\u00e3o ser poss\u00edvel identificar exatamente o tamanho de cada campo, mas \u00e9 esperado que voc\u00ea identifique ao menos o tamanho m\u00e1ximo de cada um. Question Baseado nas respostas acima, declare abaixo o struct . Escreva-o da mesma maneira que usaria em um programa em C . Examinando a execu\u00e7\u00e3o de programas usando gdb \u00b6 Podemos examinar um programa durante sua execu\u00e7\u00e3o usando o gdb . Podemos parar em qualquer instru\u00e7\u00e3o do programa, examinar conte\u00fado de registradores e da mem\u00f3ria e listar todos os s\u00edmbolos dispon\u00edveis (que podem ser fun\u00e7\u00f5es ou vari\u00e1veis globais). Example Para compilar um programa com suporte a debugging usamos a flag -g do gcc $> gcc -g -Wall -pedantic exemplo1.c Siga os passos abaixo para para carregar um programa usando o gdb . Lance o gdb e passe para ele seu programa: $> gdb ./exemplo1 Isto nos colocar\u00e1 em um prompt esperando comandos. Para rodar o programa at\u00e9 o fim execute (gdb) run Para sair, (gdb) quit Tip O gdb \u00e9 uma ferramenta poderosa que possui muitas op\u00e7\u00f5es. Sua documenta\u00e7\u00e3o est\u00e1 online e pode ser vista em https://sourceware.org/gdb/current/onlinedocs/gdb/index.html#Top . Nesta primeira parte iremos abrir o arquivo parte2.c e olhar seu conte\u00fado. Tamb\u00e9m executaremos o programa compilado parte2 . Question Abra o c\u00f3digo parte2.c e liste os nomes das vari\u00e1veis globais declaradas e seus tamanhos. Anote tamb\u00e9m as fun\u00e7\u00f5es declaradas. Question O comando info mostra informa\u00e7\u00f5es que podem ser obtidas a partir de um execut\u00e1vel. Pesquise como usar este comando para listar as vari\u00e1veis globais e as fun\u00e7\u00f5es deste execut\u00e1vel. Voc\u00ea consegue encontrar as informa\u00e7\u00f5es listadas no exerc\u00edcio anterior? Escreva abaixo os comandos usados e as informa\u00e7\u00f5es obtidas Warning Muitos dos nomes s\u00e3o estranhos. Eles fazem parte do padr\u00e3o de arquivos execut\u00e1veis ELF , que cont\u00e9m informa\u00e7\u00f5es espec\u00edficas do sistema operacional usado. Voc\u00ea n\u00e3o precisa se preocupar com estes nomes. Question Qual \u00e9 o significado da primeira coluna do comando info variables ? Dica : o valor est\u00e1 em hexadecimal, que usamos na expositiva para mostrar ponteiros. Example Podemos usar o comando print para mostrar o valor inicial das vari\u00e1veis globais identificadas. Fa\u00e7a isto para as vari\u00e1veis identificadas acima. Escreva os comandos abaixo. Dicas: Pode n\u00e3o funcionar de primeira. O qu\u00ea a mensagem de erro diz? A sintaxe de convers\u00e3o de tipos ( casting ) pode ser \u00fatil aqui. Example Podemos usar o gdb tamb\u00e9m para examinar a mem\u00f3ria de um execut\u00e1vel. A se\u00e7\u00e3o 10.6 da documenta\u00e7\u00e3o explica como usar o comando explore ( x ) para examinar a mem\u00f3ria. Acesse esta p\u00e1gina da documenta\u00e7\u00e3o, entenda seu conte\u00fado e escreva abaixo qual o comando usado para mostrar o conte\u00fado do segundo item do vetor global_array . Dicas : volte no exerc\u00edcio 3 e encontre o endere\u00e7o do in\u00edcio do vetor calcule o endere\u00e7o do segundo elemento manualmente e passe para o comando x n\u00e3o se esque\u00e7a de buscar na mem\u00f3ria o tamanho correto do elemento Example Mostre agora o conte\u00fado de cada um dos bytes do item anterior. Ou seja, voc\u00ea dever\u00e1 dar dois comandos para examinar a mem\u00f3ria. Explique como converter esses dois bytes para o valor mostrado no exerc\u00edcio anterior. Example Use agora o comando x para exibir global_str como uma string . Escreva o comando abaixo.","title":"03 - Representa\u00e7\u00e3o de dados em RAM"},{"location":"aulas/03-ram/#03-representacao-de-dados-em-ram","text":"","title":"03 - Representa\u00e7\u00e3o de dados em RAM"},{"location":"aulas/03-ram/#experimentos","text":"Vamos trabalhar com os arquivos experimento0-4.c . Compile e execute cada um deles e coloque suas sa\u00eddas abaixo. Comente os resultados comparando os valores das constantes no c\u00f3digo em C e a sa\u00edda dos programas. Question Examine o c\u00f3digo C do arquivo experimento0.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento1.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento2.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento3.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa. Question Examine o c\u00f3digo C do arquivo experimento4.c e compare com o resultado de sua execu\u00e7\u00e3o. H\u00e1 algo estranho? Se sim, escreva abaixo algumas hip\u00f3teses para o comportamento do programa.","title":"Experimentos"},{"location":"aulas/03-ram/#representacao-de-struct-em-ram","text":"A utiliza\u00e7\u00e3o de struct junta tudo que j\u00e1 vimos sobre representa\u00e7\u00e3o de todos os tipos de dados na mem\u00f3ria. N\u00e3o se esque\u00e7a de levar em conta as quest\u00f5es de alinhamento mostradas na parte expositiva da aula. Warning Voc\u00ea n\u00e3o dever\u00e1 abrir o c\u00f3digo de parte1.c . Ele est\u00e1 no reposit\u00f3rio para voc\u00ea poder conferir suas respostas. Example A segunda parte da sa\u00edda de parte1 mostra os endere\u00e7os de cada campo do struct. Note que &one e &one.icon s\u00e3o iguais. Voc\u00ea consegue explicar por que? Se n\u00e3o, volte na aula expositiva e reveja a parte sobre struct e alinhamento de mem\u00f3ria. Example Os endere\u00e7os mostrados na sa\u00edda de parte1 pertencem a um s\u00f3 struct declarado como struct player one . Quais s\u00e3o os tamanhos de cada campo? Dica : pode n\u00e3o ser poss\u00edvel identificar exatamente o tamanho de cada campo, mas \u00e9 esperado que voc\u00ea identifique ao menos o tamanho m\u00e1ximo de cada um. Question Baseado nas respostas acima, declare abaixo o struct . Escreva-o da mesma maneira que usaria em um programa em C .","title":"Representa\u00e7\u00e3o de struct em RAM"},{"location":"aulas/03-ram/#examinando-a-execucao-de-programas-usando-gdb","text":"Podemos examinar um programa durante sua execu\u00e7\u00e3o usando o gdb . Podemos parar em qualquer instru\u00e7\u00e3o do programa, examinar conte\u00fado de registradores e da mem\u00f3ria e listar todos os s\u00edmbolos dispon\u00edveis (que podem ser fun\u00e7\u00f5es ou vari\u00e1veis globais). Example Para compilar um programa com suporte a debugging usamos a flag -g do gcc $> gcc -g -Wall -pedantic exemplo1.c Siga os passos abaixo para para carregar um programa usando o gdb . Lance o gdb e passe para ele seu programa: $> gdb ./exemplo1 Isto nos colocar\u00e1 em um prompt esperando comandos. Para rodar o programa at\u00e9 o fim execute (gdb) run Para sair, (gdb) quit Tip O gdb \u00e9 uma ferramenta poderosa que possui muitas op\u00e7\u00f5es. Sua documenta\u00e7\u00e3o est\u00e1 online e pode ser vista em https://sourceware.org/gdb/current/onlinedocs/gdb/index.html#Top . Nesta primeira parte iremos abrir o arquivo parte2.c e olhar seu conte\u00fado. Tamb\u00e9m executaremos o programa compilado parte2 . Question Abra o c\u00f3digo parte2.c e liste os nomes das vari\u00e1veis globais declaradas e seus tamanhos. Anote tamb\u00e9m as fun\u00e7\u00f5es declaradas. Question O comando info mostra informa\u00e7\u00f5es que podem ser obtidas a partir de um execut\u00e1vel. Pesquise como usar este comando para listar as vari\u00e1veis globais e as fun\u00e7\u00f5es deste execut\u00e1vel. Voc\u00ea consegue encontrar as informa\u00e7\u00f5es listadas no exerc\u00edcio anterior? Escreva abaixo os comandos usados e as informa\u00e7\u00f5es obtidas Warning Muitos dos nomes s\u00e3o estranhos. Eles fazem parte do padr\u00e3o de arquivos execut\u00e1veis ELF , que cont\u00e9m informa\u00e7\u00f5es espec\u00edficas do sistema operacional usado. Voc\u00ea n\u00e3o precisa se preocupar com estes nomes. Question Qual \u00e9 o significado da primeira coluna do comando info variables ? Dica : o valor est\u00e1 em hexadecimal, que usamos na expositiva para mostrar ponteiros. Example Podemos usar o comando print para mostrar o valor inicial das vari\u00e1veis globais identificadas. Fa\u00e7a isto para as vari\u00e1veis identificadas acima. Escreva os comandos abaixo. Dicas: Pode n\u00e3o funcionar de primeira. O qu\u00ea a mensagem de erro diz? A sintaxe de convers\u00e3o de tipos ( casting ) pode ser \u00fatil aqui. Example Podemos usar o gdb tamb\u00e9m para examinar a mem\u00f3ria de um execut\u00e1vel. A se\u00e7\u00e3o 10.6 da documenta\u00e7\u00e3o explica como usar o comando explore ( x ) para examinar a mem\u00f3ria. Acesse esta p\u00e1gina da documenta\u00e7\u00e3o, entenda seu conte\u00fado e escreva abaixo qual o comando usado para mostrar o conte\u00fado do segundo item do vetor global_array . Dicas : volte no exerc\u00edcio 3 e encontre o endere\u00e7o do in\u00edcio do vetor calcule o endere\u00e7o do segundo elemento manualmente e passe para o comando x n\u00e3o se esque\u00e7a de buscar na mem\u00f3ria o tamanho correto do elemento Example Mostre agora o conte\u00fado de cada um dos bytes do item anterior. Ou seja, voc\u00ea dever\u00e1 dar dois comandos para examinar a mem\u00f3ria. Explique como converter esses dois bytes para o valor mostrado no exerc\u00edcio anterior. Example Use agora o comando x para exibir global_str como uma string . Escreva o comando abaixo.","title":"Examinando a execu\u00e7\u00e3o de programas usando gdb"},{"location":"aulas/04-asm-1/","text":"04 - Registradores x64 e vari\u00e1veis globais \u00b6 No handout passado usamos o gdb para listar vari\u00e1veis globais, nomes de fun\u00e7\u00f5es e examinar endere\u00e7os de mem\u00f3ria. Neste handout vamos come\u00e7ar a usar o gdb tamb\u00e9m para examinar nossos programas durante sua execu\u00e7\u00e3o . Parando e continuando a execu\u00e7\u00e3o de um programa. \u00b6 Example Compile funcao1.c usando as flags da disciplina ( -Og -g -Wall -std=c99 ) Example Abra o arquivo com o gdb e liste suas fun\u00e7\u00f5es e suas vari\u00e1veis globais. N\u00e3o rode o programa ainda! Anote abaixo seus endere\u00e7os e nomes. Example O comando disas \u00e9 usado para mostrar as instru\u00e7\u00f5es de m\u00e1quina de uma fun\u00e7\u00e3o. Use-o para ver o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao1 . Liste abaixo quais registradores foram usados nesta fun\u00e7\u00e3o e qual o tamanho dos dados guardados neles. Example Com base nos tamanhos identificados, voc\u00ea consegue associar os registradores acima com as vari\u00e1veis no c\u00f3digo de funcao1 ? Example Use o comando breakpoint funcao1 para parar a execu\u00e7\u00e3o do programa quando a fun\u00e7\u00e3o funcao1 come\u00e7ar a executar. Execute o programa usando run . O qu\u00ea ocorre? Example Podemos usar o comando info registers edi para ver o conte\u00fado atual do registrador %edi . Qual \u00e9 este valor? Verifique quais argumentos s\u00e3o passados para funcao1 no c\u00f3digo C e, com estas informa\u00e7\u00f5es em m\u00e3os, verifique sua resposta do exerc\u00edcio 3 e escreva abaixo suas novas conclus\u00f5es. Example O comando stepi executa exatamente uma instru\u00e7\u00e3o de m\u00e1quina. Use-o uma vez e execute novamente disas funcao1 . O que aconteceu? \u00c9 poss\u00edvel saber em qual instru\u00e7\u00e3o o programa est\u00e1 parado? Example Cheque novamente o valor de %edi . Este valor condiz com a instru\u00e7\u00e3o executada? O que ela faz, exatamente? Example Use stepi para parar logo antes do retorno da fun\u00e7\u00e3o. Verifique o conte\u00fado do registrador %eax e compare-o com os prints feitos pelo program. Voc\u00ea consegue dizer seu uso? \\vspace{3em} Example Vamos agora analisar o registrador %rsi . Toda vez que um registrador aparece entre ( ) estamos fazendo um acesso a mem\u00f3ria. Ao mostrar seu conte\u00fado usando info registers rsi recebemos o endere\u00e7o de mem\u00f3ria que cont\u00e9m o dado que queremos acessar. Use o comando x para mostrar, em decimal, o int que est\u00e1 armazenado neste endere\u00e7o. \\vspace{3em} Example Execute o comando continue para continuar rodando o programa. Ele ir\u00e1 rodar at\u00e9 que o pr\u00f3ximo breakpoint seja alcan\u00e7ado ou at\u00e9 que o programa termine. Endere\u00e7amento relativo e vari\u00e1veis globais \u00b6 Na parte anterior analisamos o c\u00f3digo Assembly de nossa primeira fun\u00e7\u00e3o e vimos como mostrar o c\u00f3digo fonte de uma fun\u00e7\u00e3o usando disas mostrar o conte\u00fado de um registrador usando info registers executar exatamente uma instru\u00e7\u00e3o usando stepi Tamb\u00e9m vimos que ao colocar um registrador entre ( ) estamos fazendo um acesso a mem\u00f3ria. Esta opera\u00e7\u00e3o \u00e9 equivalente a desreferenciar um ponteiro usando *p . Neste roteiro iremos adicionar um detalhe importante: podemos fazer contas com endere\u00e7os usando esta nota\u00e7\u00e3o. Nos exemplo abaixo nos referimos a mem\u00f3ria como um grande vetor de bytes unsigned char M[] . Ou seja, ao acessar M[%rax] , por exemplo, estamos acessando o lugar na mem\u00f3ria cujo endere\u00e7o est\u00e1 escrito em %rax . 10(%rax) : acessa a mem\u00f3ria M[%rax + 10] . (%rax, %rdi, 4) : acessa a mem\u00f3ria M[%rax + 4 * % rdi] . Note que isto se parece com aritm\u00e9tica de ponteiros cujo tipo apontado seja inteiro, pois os endere\u00e7os pulam de 4 em 4 bytes. Example Saia e abra o gdb novamente. Mostre o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao2 e coloque um breakpoint em sua primeira instru\u00e7\u00e3o. Example Execute agora o programa. A execu\u00e7\u00e3o deve ter parado no in\u00edcio de funcao2 . Rode disas funcao2 . Question Voc\u00ea consegue identificar acessos a mem\u00f3ria em funcao2 ? Quais s\u00e3o de leitura e quais s\u00e3o de escrita? Qual o tamanho dos dados lidos/escritos? Question Qual o significado do registrador %rip ? Se n\u00e3o se lembrar reveja os slides. O tipo de acesso a mem\u00f3ria que estamos realizando se chama rip relative addressing . Este tipo de acesso \u00e9 reservado para vari\u00e1veis globais e dados somente leitura. Estes dados tem uma caracter\u00edstica especial: eles s\u00e3o copiados para a mem\u00f3ria seguindo o mesmo layout do arquivo execut\u00e1vel. Ou seja, as posi\u00e7\u00f5es relativas entre o c\u00f3digo e os dados globais s\u00e3o fixas. Question Anote abaixo o ende\u00e7o das fun\u00e7\u00f5es MOV que utilizam este acesso. Baseado nos exemplos acima, descubra o endere\u00e7o das vari\u00e1veis acessadas. Example Confira se o valor identificado na quest\u00e3o anterior \u00e9 o mesmo mostrado a direita das instru\u00e7\u00f5es MOV na sa\u00edda do disas . O gdb j\u00e1 calcula este endere\u00e7o para facilitar nossa vida, mas \u00e9 interessante calcular isto manualmente uma vez para entender melhor o processo. Question Use o comando continue para continuar o programa. Voc\u00ea deve estar agora na segunda execu\u00e7\u00e3o de funcao2 . Use o comando x para mostrar o valor armazenado na mem\u00f3ria calculada acima. Lendo o c\u00f3digo do programa, voc\u00ea consegue dizer qual vari\u00e1vel \u00e9 armazenada neste endere\u00e7o? O valor atual \u00e9 o esperado para a segunda execu\u00e7\u00e3o de funcao2 ? Al\u00e9m de poder mostrar valores na mem\u00f3ria podemos escrever valores tamb\u00e9m. A sintaxe usada \u00e9 a seguinte: set *( (tipo *) 0x.....) = valor onde devemos substituir tipo por um tipo b\u00e1sico de C , 0x... pelo endere\u00e7o desejado e valor pelo valor que queremos escrever. Note que o que estamos fazendo \u00e9 um cast do endere\u00e7o 0x.... para um ponteiro de tipo e depois estamos acessando o valor apontado usando * ! Question Escreva o valor -10 na mem\u00f3ria da vari\u00e1vel global usada em funcao2 . Rode o programa at\u00e9 o fim. O resultado foi o esperado? Escreva abaixo os comandos utilizados. \\vspace{5em} Desafio Localize na fun\u00e7\u00e3o main as chamadas ao comando printf . Encontre ent\u00e3o o endere\u00e7o das strings de formata\u00e7\u00e3o e use o comando x para mostr\u00e1-las no gdb. Escreva os comandos usados abaixo.","title":"04 - Registradores x64 e vari\u00e1veis globais"},{"location":"aulas/04-asm-1/#04-registradores-x64-e-variaveis-globais","text":"No handout passado usamos o gdb para listar vari\u00e1veis globais, nomes de fun\u00e7\u00f5es e examinar endere\u00e7os de mem\u00f3ria. Neste handout vamos come\u00e7ar a usar o gdb tamb\u00e9m para examinar nossos programas durante sua execu\u00e7\u00e3o .","title":"04 - Registradores x64 e vari\u00e1veis globais"},{"location":"aulas/04-asm-1/#parando-e-continuando-a-execucao-de-um-programa","text":"Example Compile funcao1.c usando as flags da disciplina ( -Og -g -Wall -std=c99 ) Example Abra o arquivo com o gdb e liste suas fun\u00e7\u00f5es e suas vari\u00e1veis globais. N\u00e3o rode o programa ainda! Anote abaixo seus endere\u00e7os e nomes. Example O comando disas \u00e9 usado para mostrar as instru\u00e7\u00f5es de m\u00e1quina de uma fun\u00e7\u00e3o. Use-o para ver o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao1 . Liste abaixo quais registradores foram usados nesta fun\u00e7\u00e3o e qual o tamanho dos dados guardados neles. Example Com base nos tamanhos identificados, voc\u00ea consegue associar os registradores acima com as vari\u00e1veis no c\u00f3digo de funcao1 ? Example Use o comando breakpoint funcao1 para parar a execu\u00e7\u00e3o do programa quando a fun\u00e7\u00e3o funcao1 come\u00e7ar a executar. Execute o programa usando run . O qu\u00ea ocorre? Example Podemos usar o comando info registers edi para ver o conte\u00fado atual do registrador %edi . Qual \u00e9 este valor? Verifique quais argumentos s\u00e3o passados para funcao1 no c\u00f3digo C e, com estas informa\u00e7\u00f5es em m\u00e3os, verifique sua resposta do exerc\u00edcio 3 e escreva abaixo suas novas conclus\u00f5es. Example O comando stepi executa exatamente uma instru\u00e7\u00e3o de m\u00e1quina. Use-o uma vez e execute novamente disas funcao1 . O que aconteceu? \u00c9 poss\u00edvel saber em qual instru\u00e7\u00e3o o programa est\u00e1 parado? Example Cheque novamente o valor de %edi . Este valor condiz com a instru\u00e7\u00e3o executada? O que ela faz, exatamente? Example Use stepi para parar logo antes do retorno da fun\u00e7\u00e3o. Verifique o conte\u00fado do registrador %eax e compare-o com os prints feitos pelo program. Voc\u00ea consegue dizer seu uso? \\vspace{3em} Example Vamos agora analisar o registrador %rsi . Toda vez que um registrador aparece entre ( ) estamos fazendo um acesso a mem\u00f3ria. Ao mostrar seu conte\u00fado usando info registers rsi recebemos o endere\u00e7o de mem\u00f3ria que cont\u00e9m o dado que queremos acessar. Use o comando x para mostrar, em decimal, o int que est\u00e1 armazenado neste endere\u00e7o. \\vspace{3em} Example Execute o comando continue para continuar rodando o programa. Ele ir\u00e1 rodar at\u00e9 que o pr\u00f3ximo breakpoint seja alcan\u00e7ado ou at\u00e9 que o programa termine.","title":"Parando e continuando a execu\u00e7\u00e3o de um programa."},{"location":"aulas/04-asm-1/#enderecamento-relativo-e-variaveis-globais","text":"Na parte anterior analisamos o c\u00f3digo Assembly de nossa primeira fun\u00e7\u00e3o e vimos como mostrar o c\u00f3digo fonte de uma fun\u00e7\u00e3o usando disas mostrar o conte\u00fado de um registrador usando info registers executar exatamente uma instru\u00e7\u00e3o usando stepi Tamb\u00e9m vimos que ao colocar um registrador entre ( ) estamos fazendo um acesso a mem\u00f3ria. Esta opera\u00e7\u00e3o \u00e9 equivalente a desreferenciar um ponteiro usando *p . Neste roteiro iremos adicionar um detalhe importante: podemos fazer contas com endere\u00e7os usando esta nota\u00e7\u00e3o. Nos exemplo abaixo nos referimos a mem\u00f3ria como um grande vetor de bytes unsigned char M[] . Ou seja, ao acessar M[%rax] , por exemplo, estamos acessando o lugar na mem\u00f3ria cujo endere\u00e7o est\u00e1 escrito em %rax . 10(%rax) : acessa a mem\u00f3ria M[%rax + 10] . (%rax, %rdi, 4) : acessa a mem\u00f3ria M[%rax + 4 * % rdi] . Note que isto se parece com aritm\u00e9tica de ponteiros cujo tipo apontado seja inteiro, pois os endere\u00e7os pulam de 4 em 4 bytes. Example Saia e abra o gdb novamente. Mostre o c\u00f3digo de m\u00e1quina da fun\u00e7\u00e3o funcao2 e coloque um breakpoint em sua primeira instru\u00e7\u00e3o. Example Execute agora o programa. A execu\u00e7\u00e3o deve ter parado no in\u00edcio de funcao2 . Rode disas funcao2 . Question Voc\u00ea consegue identificar acessos a mem\u00f3ria em funcao2 ? Quais s\u00e3o de leitura e quais s\u00e3o de escrita? Qual o tamanho dos dados lidos/escritos? Question Qual o significado do registrador %rip ? Se n\u00e3o se lembrar reveja os slides. O tipo de acesso a mem\u00f3ria que estamos realizando se chama rip relative addressing . Este tipo de acesso \u00e9 reservado para vari\u00e1veis globais e dados somente leitura. Estes dados tem uma caracter\u00edstica especial: eles s\u00e3o copiados para a mem\u00f3ria seguindo o mesmo layout do arquivo execut\u00e1vel. Ou seja, as posi\u00e7\u00f5es relativas entre o c\u00f3digo e os dados globais s\u00e3o fixas. Question Anote abaixo o ende\u00e7o das fun\u00e7\u00f5es MOV que utilizam este acesso. Baseado nos exemplos acima, descubra o endere\u00e7o das vari\u00e1veis acessadas. Example Confira se o valor identificado na quest\u00e3o anterior \u00e9 o mesmo mostrado a direita das instru\u00e7\u00f5es MOV na sa\u00edda do disas . O gdb j\u00e1 calcula este endere\u00e7o para facilitar nossa vida, mas \u00e9 interessante calcular isto manualmente uma vez para entender melhor o processo. Question Use o comando continue para continuar o programa. Voc\u00ea deve estar agora na segunda execu\u00e7\u00e3o de funcao2 . Use o comando x para mostrar o valor armazenado na mem\u00f3ria calculada acima. Lendo o c\u00f3digo do programa, voc\u00ea consegue dizer qual vari\u00e1vel \u00e9 armazenada neste endere\u00e7o? O valor atual \u00e9 o esperado para a segunda execu\u00e7\u00e3o de funcao2 ? Al\u00e9m de poder mostrar valores na mem\u00f3ria podemos escrever valores tamb\u00e9m. A sintaxe usada \u00e9 a seguinte: set *( (tipo *) 0x.....) = valor onde devemos substituir tipo por um tipo b\u00e1sico de C , 0x... pelo endere\u00e7o desejado e valor pelo valor que queremos escrever. Note que o que estamos fazendo \u00e9 um cast do endere\u00e7o 0x.... para um ponteiro de tipo e depois estamos acessando o valor apontado usando * ! Question Escreva o valor -10 na mem\u00f3ria da vari\u00e1vel global usada em funcao2 . Rode o programa at\u00e9 o fim. O resultado foi o esperado? Escreva abaixo os comandos utilizados. \\vspace{5em} Desafio Localize na fun\u00e7\u00e3o main as chamadas ao comando printf . Encontre ent\u00e3o o endere\u00e7o das strings de formata\u00e7\u00e3o e use o comando x para mostr\u00e1-las no gdb. Escreva os comandos usados abaixo.","title":"Endere\u00e7amento relativo e vari\u00e1veis globais"},{"location":"aulas/05-funcoes/","text":"05 - Fun\u00e7\u00f5es \u00b6 Neste handout vamos trabalhar pela primeira vez na tradu\u00e7\u00e3o reversa de programas em Assembly para C . Nas \u00faltimas aulas vimos as instru\u00e7\u00f5es mov e add e na aula de hoje vimos uma tabela grande com as instru\u00e7\u00f5es aritm\u00e9ticas ( add , sub , mul , imul , div , etc). Como em todas as aulas, veremos hoje um detalhe a mais sobre arquitetura x64 : chamadas de fun\u00e7\u00f5es e argumentos. Fun\u00e7\u00f5es e seus argumentos \u00b6 Em x64 os argumentos das fun\u00e7\u00f5es s\u00e3o passados nos registradores e o valor de retorno \u00e9 colocado tamb\u00e9m em um registrador. Argumentos inteiros ou ponteiros s\u00e3o passados nos registradores %rdi , %rsi , %rdx , %rcx , %r8 e %r9 ( nesta ordem ). Argumentos ponto flutuante s\u00e3o passados nos registradores %xmm0 at\u00e9 %xmm7 . Valores de retorno inteiros ou ponteiros s\u00e3o colocados no registrador %rax . Valores de retorno ponto flutuante s\u00e3o colocados no registrador %xmm0 . Para chamar fun\u00e7\u00f5es usamos a instru\u00e7\u00e3o call seguido do endere\u00e7o de mem\u00f3ria da fun\u00e7\u00e3o. O gdb cria um \"apelido\" para estes endere\u00e7os de mem\u00f3ria usando o nome original da fun\u00e7\u00e3o no arquivo .c . Assim, estas instru\u00e7\u00f5es s\u00e3o mostradas, normalmente, como call func1 , por exemplo. Note que antes de cada call devemos preencher os argumentos nos registradores corretos. Para retornar usamos a instru\u00e7\u00e3o ret . Ela \u00e9 equivalente ao comando return de C e devolver\u00e1 o valor armazenado no %rax (ou %xmm0 para ponto flutuante). N\u00e3o se esque\u00e7a da equival\u00eancia entre o tamanhos dos registradores e os tipos inteiros em C . Um resumo gr\u00e1fico pode ser visto nas figuras acima. 64 bits ( %rax , %rdi e outros que come\u00e7am com r ): ( unsigned ) long ou ponteiro; 32 bits ( %eax , %edi e outros que come\u00e7a com e e os que terminam em d como r10d ): int ou unsigned int ; 16 bits ( %ax , %di e outros com duas letras somente terminando em x ): short ou unsigned short 8 bits ( %al , %ah e outros com duas letras terminando em h ou l ): char ou unsigned char . Vamos agora praticar fazendo a tradu\u00e7\u00e3o de fun\u00e7\u00f5es que fazem aritm\u00e9tica simples entre inteiros (usando ou n\u00e3o ponteiros). O exemplo abaixo mostra todas as etapas que precisamos seguir para fazer a tradu\u00e7\u00e3o Assembly -> C. Exemplo guiado \u00b6 Dado o c\u00f3digo Assembly abaixo, fa\u00e7a sua tradu\u00e7\u00e3o para C 0000000000000000 <misterio1>: 0: 48 01 f7 add %rsi,%rdi 3: 48 8d 04 57 lea (%rdi,%rdx,2),%rax 7: c3 retq Assinatura da fun\u00e7\u00e3o \u00b6 Vamos come\u00e7ar pela assinatura da fun\u00e7\u00e3o. \u00c9 sempre \u00fatil identificar quais registradores s\u00e3o lidos antes de serem escritos. Isso nos ajuda a entender se um registrador \u00e9 um argumento da fun\u00e7\u00e3o ou se ele \u00e9 apenas usado como vari\u00e1vel local. Faremos isso escrevendo todos os registradores que podem ser argumentos em ordem e vendo se s\u00e3o lidos ou escritos primeiro: %rdi - lido primeiro ( add faz a opera\u00e7\u00e3o += ) %rsi - lido primeiro (no lado esquerdo do add ) %rdx - lido primeiro (no lado esquerdo do lea ) %rcx - n\u00e3o usado %r8 - n\u00e3o usado %r9 - n\u00e3o usado Logo, os registradores %rdi , %rsi e %rdx s\u00e3o argumentos da fun\u00e7\u00e3o. Consultando o box de arquitetura de computadores, vemos que a fun\u00e7\u00e3o recebe tr\u00eas argumentos do tipo long (pois usa os registradores de 64 bits). Note que o resultado das computa\u00e7\u00f5es \u00e9 guardado em %rax , que guarda sempre o retorno da fun\u00e7\u00e3o. Por usar a por\u00e7\u00e3o de 64 bits do registrador, o tipo de retorno tamb\u00e9m \u00e9 long . A assinatura da fun\u00e7\u00e3o \u00e9, portanto long misterio1(long a, long b, long c); Tip Ponteiros tamb\u00e9m usam os registradores de 64 bits. Por\u00e9m, olhando rapidamente o c\u00f3digo notamos que n\u00e3o h\u00e1 nenhum acesso a mem\u00f3ria. Logo, se trata realmente de long . O c\u00f3digo \u00b6 Vamos agora para o c\u00f3digo. Nossa primeira estrat\u00e9gia \u00e9 atribuir um nome para cada registrador. Os tr\u00eas registradores de argumentos j\u00e1 receberam os nomes a , b e c . Para deixar expl\u00edcito o papel do %rax vamos nome\u00e1-lo de retval . A primeira instru\u00e7\u00e3o add %rsi, %rdi realiza a adi\u00e7\u00e3o dos dois registradores e armazena em %rdi . Logo, sua tradu\u00e7\u00e3o direta seria: a += b ; A instru\u00e7\u00e3o lea (%rdi, %rdx, 2), %rax \u00e9 usada tanto para calcular endere\u00e7os de mem\u00f3ria quanto para aritm\u00e9tica simples. Vemos que \u00e9 o segundo caso pois, no c\u00f3digo seguinte, n\u00e3o acessamos a mem\u00f3ria com o valor calculado. Logo, podemos traduzir este trecho como retval = a + 2 * c ; Logo ap\u00f3s temos o ret , que \u00e9 traduzido como return retval ; Logo, nossa fun\u00e7\u00e3o \u00e9 traduzida como long misterio1 ( long a , long b , long c ){ long retval ; a += b ; retval = a + 2 * c ; return retval ; } Finalmente, podemos deixar nosso c\u00f3digo leg\u00edvel e escrev\u00ea-lo como long misterio1 ( long a , long b , long c ){ return a + b + 2 * c ; } Voc\u00ea pode verificar o c\u00f3digo original no arquivo exemplo1.c . O processo acima pode ser formalizado no seguinte algoritmo: Identifique quantos argumentos a fun\u00e7\u00e3o recebe Identifique os tipos de cada argumento (pode ser necess\u00e1rio olhar o c\u00f3digo assembly da fun\u00e7\u00e3o) D\u00ea um nome para cada registrador. Se um mesmo registrador \u00e9 usado com tamanhos diferentes ( %rdi e %edi s\u00e3o usados no c\u00f3digo), d\u00ea um nome diferente para cada tamanho. Fa\u00e7a a tradu\u00e7\u00e3o de cada instru\u00e7\u00e3o separadamente. Fique atento aos valores colocados em %rax e %eax perto do fim do c\u00f3digo. Esses valores ser\u00e3o retornados pela fun\u00e7\u00e3o. O c\u00f3digo gerado costuma ser ileg\u00edvel. Refatore-o para melhorar sua legibilidade. Tip A instru\u00e7\u00e3o lea pode ser usada tanto para aritm\u00e9tica quanto para c\u00e1lculo de endere\u00e7os. Para tirar a d\u00favida basta olhar se as pr\u00f3ximas instru\u00e7\u00f5es fazem acesso \u00e0 mem\u00f3ria com o endere\u00e7o calculado ou apenas usam o valor diretamente (aritm\u00e9tica). Os registradores de tamanhos menores s\u00e3o virtuais. Quanto escrevo em %ax estou escrevendo nos 16 bits menos significativos de %rax e de %eax tamb\u00e9m. Muitas instru\u00e7\u00f5es com operadores de 32bits zeram os 32bits superiores. Assim, vemos por exemplo a instru\u00e7\u00e3o mov $0, %eax sendo usada para zerar um long . Nesses casos \u00e9 necess\u00e1rio verificar se a fun\u00e7\u00e3o continua usando %eax (\u00e9 int mesmo) ou se ela magicamente passa a usar %rax (o tipo era long ). Pr\u00e1tica \u00b6 Vamos agora exercitar. Cada exerc\u00edcio faz um c\u00e1lculo diferente. Se houver alguma instru\u00e7\u00e3o desconhecida, pesquise-a no google para encontrar seu significado. Normalmente algo como \"asm x64 instruction\" + a instru\u00e7\u00e3o desconhecida d\u00e1 respostas corretas. Warning Usaremos o gdb para abrir os arquivos .o nesta aula. Este tipo de arquivo cont\u00e9m fun\u00e7\u00f5es compiladas, mas n\u00e3o \u00e9 um execut\u00e1vel completo por n\u00e3o ter uma fun\u00e7\u00e3o main . Arquivo ex1.o \u00b6 Question O c\u00f3digo abaixo foi retirado do arquivo ex1.o . Fa\u00e7a sua tradu\u00e7\u00e3o para C . 0000000000000000 <ex1>: 0: 89 f8 mov %edi,%eax 2: 29 f0 sub %esi,%eax 4: c3 retq Arquivo ex2.o \u00b6 Question Use o gdb para listar as fun\u00e7\u00f5es definidas em ex2.o e escreva-as abaixo. Question Fa\u00e7a a tradu\u00e7\u00e3o das fun\u00e7\u00f5es acima para C Arquivo ex3.o \u00b6 A fun\u00e7\u00e3o abaixo foi obtida de ex3.o . 0000000000000000 <ex3>: 0: 8b 06 mov (%rsi),%eax 2: 0f af c0 imul %eax,%eax 5: 89 07 mov %eax,(%rdi) 7: c3 retq Question O qu\u00ea faz a instru\u00e7\u00e3o imul ? Question Traduza esta fun\u00e7\u00e3o para C . Fique atento ao tamanho dos registradores usados para identificar o tamanho dos vari\u00e1veis inteiras. Antes de prosseguir, valide suas solu\u00e7\u00f5es da se\u00e7\u00e3o anterior com o professor. Vamos agora trabalhar com execut\u00e1veis \"completos\". Vamos analisar n\u00e3o somente o c\u00f3digo das fun\u00e7\u00f5es mas tamb\u00e9m sua chamada. Arquivo ex4 \u00b6 Example Use o gdb para obter o conte\u00fado das fun\u00e7\u00f5es main e ex4 . Dica : lembre-se do comando disas Localize a chamada da fun\u00e7\u00e3o ex4 no main. As intru\u00e7\u00f5es acima do call colocam os argumentos nos lugares corretos para ex4 rodar. Question Quantos argumentos a fun\u00e7\u00e3o recebe? Quais s\u00e3o seus valores? Question Traduza a fun\u00e7\u00e3o ex4 para C . Arquivo ex5 (desafio) \u00b6 Warning Este exerc\u00edcio \u00e9 avan\u00e7ado e necessita de pesquisa para ser realizado. Fa\u00e7a-o somente ap\u00f3s validar suas solu\u00e7\u00f5es dos anteriores com os professores. Neste exerc\u00edcio vamos nos aprofundar no uso de ponteiros. Vimos no ex3.o um exemplo de fun\u00e7\u00e3o que armazenava um valor calculado em um ponteiro. Agora veremos um exemplo completo que inclui a chamada de uma fun\u00e7\u00e3o recebendo um endere\u00e7o. O trecho abaixo copia os argumentos para os registradores corretos e chama a fun\u00e7\u00e3o. 60b: 48 8d 4c 24 08 lea 0x8(%rsp),%rcx 610: 48 8d 54 24 0c lea 0xc(%rsp),%rdx 615: be 03 00 00 00 mov $0x3,%esi 61a: bf 0a 00 00 00 mov $0xa,%edi 61f: e8 d6 ff ff ff callq 5fa <ex5> Question Identifique a partir dos tipos de dados colocados nos registradores qual o tipo dos argumentos da fun\u00e7\u00e3o. Question Qual s\u00e3o os endere\u00e7os passados para a fun\u00e7\u00e3o ex5 ? Escreva-os em fun\u00e7\u00e3o do registrador %rsp . Question Os endere\u00e7os acima s\u00e3o passados em quais registradores? Vamos agora ao c\u00f3digo de ex5 : 00000000000005fa <ex5>: 5fa: 89 f8 mov %edi,%eax 5fc: 48 89 d7 mov %rdx,%rdi 5ff: 99 cltd 600: f7 fe idiv %esi 602: 89 07 mov %eax,(%rdi) 604: 89 11 mov %edx,(%rcx) 606: c3 retq Question Como a instru\u00e7\u00e3o idiv funciona? Em quais registradores ela posiciona seu resultado? Em quais registradores ela espera a entrada? Question O qu\u00ea faz a instru\u00e7\u00e3o cltd ? Por qu\u00ea ela \u00e9 necess\u00e1ria? Question Fa\u00e7a a tradu\u00e7\u00e3o de ex5 para C .","title":"05 - Fun\u00e7\u00f5es"},{"location":"aulas/05-funcoes/#05-funcoes","text":"Neste handout vamos trabalhar pela primeira vez na tradu\u00e7\u00e3o reversa de programas em Assembly para C . Nas \u00faltimas aulas vimos as instru\u00e7\u00f5es mov e add e na aula de hoje vimos uma tabela grande com as instru\u00e7\u00f5es aritm\u00e9ticas ( add , sub , mul , imul , div , etc). Como em todas as aulas, veremos hoje um detalhe a mais sobre arquitetura x64 : chamadas de fun\u00e7\u00f5es e argumentos.","title":"05 - Fun\u00e7\u00f5es"},{"location":"aulas/05-funcoes/#funcoes-e-seus-argumentos","text":"Em x64 os argumentos das fun\u00e7\u00f5es s\u00e3o passados nos registradores e o valor de retorno \u00e9 colocado tamb\u00e9m em um registrador. Argumentos inteiros ou ponteiros s\u00e3o passados nos registradores %rdi , %rsi , %rdx , %rcx , %r8 e %r9 ( nesta ordem ). Argumentos ponto flutuante s\u00e3o passados nos registradores %xmm0 at\u00e9 %xmm7 . Valores de retorno inteiros ou ponteiros s\u00e3o colocados no registrador %rax . Valores de retorno ponto flutuante s\u00e3o colocados no registrador %xmm0 . Para chamar fun\u00e7\u00f5es usamos a instru\u00e7\u00e3o call seguido do endere\u00e7o de mem\u00f3ria da fun\u00e7\u00e3o. O gdb cria um \"apelido\" para estes endere\u00e7os de mem\u00f3ria usando o nome original da fun\u00e7\u00e3o no arquivo .c . Assim, estas instru\u00e7\u00f5es s\u00e3o mostradas, normalmente, como call func1 , por exemplo. Note que antes de cada call devemos preencher os argumentos nos registradores corretos. Para retornar usamos a instru\u00e7\u00e3o ret . Ela \u00e9 equivalente ao comando return de C e devolver\u00e1 o valor armazenado no %rax (ou %xmm0 para ponto flutuante). N\u00e3o se esque\u00e7a da equival\u00eancia entre o tamanhos dos registradores e os tipos inteiros em C . Um resumo gr\u00e1fico pode ser visto nas figuras acima. 64 bits ( %rax , %rdi e outros que come\u00e7am com r ): ( unsigned ) long ou ponteiro; 32 bits ( %eax , %edi e outros que come\u00e7a com e e os que terminam em d como r10d ): int ou unsigned int ; 16 bits ( %ax , %di e outros com duas letras somente terminando em x ): short ou unsigned short 8 bits ( %al , %ah e outros com duas letras terminando em h ou l ): char ou unsigned char . Vamos agora praticar fazendo a tradu\u00e7\u00e3o de fun\u00e7\u00f5es que fazem aritm\u00e9tica simples entre inteiros (usando ou n\u00e3o ponteiros). O exemplo abaixo mostra todas as etapas que precisamos seguir para fazer a tradu\u00e7\u00e3o Assembly -> C.","title":"Fun\u00e7\u00f5es e seus argumentos"},{"location":"aulas/05-funcoes/#exemplo-guiado","text":"Dado o c\u00f3digo Assembly abaixo, fa\u00e7a sua tradu\u00e7\u00e3o para C 0000000000000000 <misterio1>: 0: 48 01 f7 add %rsi,%rdi 3: 48 8d 04 57 lea (%rdi,%rdx,2),%rax 7: c3 retq","title":"Exemplo guiado"},{"location":"aulas/05-funcoes/#assinatura-da-funcao","text":"Vamos come\u00e7ar pela assinatura da fun\u00e7\u00e3o. \u00c9 sempre \u00fatil identificar quais registradores s\u00e3o lidos antes de serem escritos. Isso nos ajuda a entender se um registrador \u00e9 um argumento da fun\u00e7\u00e3o ou se ele \u00e9 apenas usado como vari\u00e1vel local. Faremos isso escrevendo todos os registradores que podem ser argumentos em ordem e vendo se s\u00e3o lidos ou escritos primeiro: %rdi - lido primeiro ( add faz a opera\u00e7\u00e3o += ) %rsi - lido primeiro (no lado esquerdo do add ) %rdx - lido primeiro (no lado esquerdo do lea ) %rcx - n\u00e3o usado %r8 - n\u00e3o usado %r9 - n\u00e3o usado Logo, os registradores %rdi , %rsi e %rdx s\u00e3o argumentos da fun\u00e7\u00e3o. Consultando o box de arquitetura de computadores, vemos que a fun\u00e7\u00e3o recebe tr\u00eas argumentos do tipo long (pois usa os registradores de 64 bits). Note que o resultado das computa\u00e7\u00f5es \u00e9 guardado em %rax , que guarda sempre o retorno da fun\u00e7\u00e3o. Por usar a por\u00e7\u00e3o de 64 bits do registrador, o tipo de retorno tamb\u00e9m \u00e9 long . A assinatura da fun\u00e7\u00e3o \u00e9, portanto long misterio1(long a, long b, long c); Tip Ponteiros tamb\u00e9m usam os registradores de 64 bits. Por\u00e9m, olhando rapidamente o c\u00f3digo notamos que n\u00e3o h\u00e1 nenhum acesso a mem\u00f3ria. Logo, se trata realmente de long .","title":"Assinatura da fun\u00e7\u00e3o"},{"location":"aulas/05-funcoes/#o-codigo","text":"Vamos agora para o c\u00f3digo. Nossa primeira estrat\u00e9gia \u00e9 atribuir um nome para cada registrador. Os tr\u00eas registradores de argumentos j\u00e1 receberam os nomes a , b e c . Para deixar expl\u00edcito o papel do %rax vamos nome\u00e1-lo de retval . A primeira instru\u00e7\u00e3o add %rsi, %rdi realiza a adi\u00e7\u00e3o dos dois registradores e armazena em %rdi . Logo, sua tradu\u00e7\u00e3o direta seria: a += b ; A instru\u00e7\u00e3o lea (%rdi, %rdx, 2), %rax \u00e9 usada tanto para calcular endere\u00e7os de mem\u00f3ria quanto para aritm\u00e9tica simples. Vemos que \u00e9 o segundo caso pois, no c\u00f3digo seguinte, n\u00e3o acessamos a mem\u00f3ria com o valor calculado. Logo, podemos traduzir este trecho como retval = a + 2 * c ; Logo ap\u00f3s temos o ret , que \u00e9 traduzido como return retval ; Logo, nossa fun\u00e7\u00e3o \u00e9 traduzida como long misterio1 ( long a , long b , long c ){ long retval ; a += b ; retval = a + 2 * c ; return retval ; } Finalmente, podemos deixar nosso c\u00f3digo leg\u00edvel e escrev\u00ea-lo como long misterio1 ( long a , long b , long c ){ return a + b + 2 * c ; } Voc\u00ea pode verificar o c\u00f3digo original no arquivo exemplo1.c . O processo acima pode ser formalizado no seguinte algoritmo: Identifique quantos argumentos a fun\u00e7\u00e3o recebe Identifique os tipos de cada argumento (pode ser necess\u00e1rio olhar o c\u00f3digo assembly da fun\u00e7\u00e3o) D\u00ea um nome para cada registrador. Se um mesmo registrador \u00e9 usado com tamanhos diferentes ( %rdi e %edi s\u00e3o usados no c\u00f3digo), d\u00ea um nome diferente para cada tamanho. Fa\u00e7a a tradu\u00e7\u00e3o de cada instru\u00e7\u00e3o separadamente. Fique atento aos valores colocados em %rax e %eax perto do fim do c\u00f3digo. Esses valores ser\u00e3o retornados pela fun\u00e7\u00e3o. O c\u00f3digo gerado costuma ser ileg\u00edvel. Refatore-o para melhorar sua legibilidade. Tip A instru\u00e7\u00e3o lea pode ser usada tanto para aritm\u00e9tica quanto para c\u00e1lculo de endere\u00e7os. Para tirar a d\u00favida basta olhar se as pr\u00f3ximas instru\u00e7\u00f5es fazem acesso \u00e0 mem\u00f3ria com o endere\u00e7o calculado ou apenas usam o valor diretamente (aritm\u00e9tica). Os registradores de tamanhos menores s\u00e3o virtuais. Quanto escrevo em %ax estou escrevendo nos 16 bits menos significativos de %rax e de %eax tamb\u00e9m. Muitas instru\u00e7\u00f5es com operadores de 32bits zeram os 32bits superiores. Assim, vemos por exemplo a instru\u00e7\u00e3o mov $0, %eax sendo usada para zerar um long . Nesses casos \u00e9 necess\u00e1rio verificar se a fun\u00e7\u00e3o continua usando %eax (\u00e9 int mesmo) ou se ela magicamente passa a usar %rax (o tipo era long ).","title":"O c\u00f3digo"},{"location":"aulas/05-funcoes/#pratica","text":"Vamos agora exercitar. Cada exerc\u00edcio faz um c\u00e1lculo diferente. Se houver alguma instru\u00e7\u00e3o desconhecida, pesquise-a no google para encontrar seu significado. Normalmente algo como \"asm x64 instruction\" + a instru\u00e7\u00e3o desconhecida d\u00e1 respostas corretas. Warning Usaremos o gdb para abrir os arquivos .o nesta aula. Este tipo de arquivo cont\u00e9m fun\u00e7\u00f5es compiladas, mas n\u00e3o \u00e9 um execut\u00e1vel completo por n\u00e3o ter uma fun\u00e7\u00e3o main .","title":"Pr\u00e1tica"},{"location":"aulas/05-funcoes/#arquivo-ex1o","text":"Question O c\u00f3digo abaixo foi retirado do arquivo ex1.o . Fa\u00e7a sua tradu\u00e7\u00e3o para C . 0000000000000000 <ex1>: 0: 89 f8 mov %edi,%eax 2: 29 f0 sub %esi,%eax 4: c3 retq","title":"Arquivo ex1.o"},{"location":"aulas/05-funcoes/#arquivo-ex2o","text":"Question Use o gdb para listar as fun\u00e7\u00f5es definidas em ex2.o e escreva-as abaixo. Question Fa\u00e7a a tradu\u00e7\u00e3o das fun\u00e7\u00f5es acima para C","title":"Arquivo ex2.o"},{"location":"aulas/05-funcoes/#arquivo-ex3o","text":"A fun\u00e7\u00e3o abaixo foi obtida de ex3.o . 0000000000000000 <ex3>: 0: 8b 06 mov (%rsi),%eax 2: 0f af c0 imul %eax,%eax 5: 89 07 mov %eax,(%rdi) 7: c3 retq Question O qu\u00ea faz a instru\u00e7\u00e3o imul ? Question Traduza esta fun\u00e7\u00e3o para C . Fique atento ao tamanho dos registradores usados para identificar o tamanho dos vari\u00e1veis inteiras. Antes de prosseguir, valide suas solu\u00e7\u00f5es da se\u00e7\u00e3o anterior com o professor. Vamos agora trabalhar com execut\u00e1veis \"completos\". Vamos analisar n\u00e3o somente o c\u00f3digo das fun\u00e7\u00f5es mas tamb\u00e9m sua chamada.","title":"Arquivo ex3.o"},{"location":"aulas/05-funcoes/#arquivo-ex4","text":"Example Use o gdb para obter o conte\u00fado das fun\u00e7\u00f5es main e ex4 . Dica : lembre-se do comando disas Localize a chamada da fun\u00e7\u00e3o ex4 no main. As intru\u00e7\u00f5es acima do call colocam os argumentos nos lugares corretos para ex4 rodar. Question Quantos argumentos a fun\u00e7\u00e3o recebe? Quais s\u00e3o seus valores? Question Traduza a fun\u00e7\u00e3o ex4 para C .","title":"Arquivo ex4"},{"location":"aulas/05-funcoes/#arquivo-ex5-desafio","text":"Warning Este exerc\u00edcio \u00e9 avan\u00e7ado e necessita de pesquisa para ser realizado. Fa\u00e7a-o somente ap\u00f3s validar suas solu\u00e7\u00f5es dos anteriores com os professores. Neste exerc\u00edcio vamos nos aprofundar no uso de ponteiros. Vimos no ex3.o um exemplo de fun\u00e7\u00e3o que armazenava um valor calculado em um ponteiro. Agora veremos um exemplo completo que inclui a chamada de uma fun\u00e7\u00e3o recebendo um endere\u00e7o. O trecho abaixo copia os argumentos para os registradores corretos e chama a fun\u00e7\u00e3o. 60b: 48 8d 4c 24 08 lea 0x8(%rsp),%rcx 610: 48 8d 54 24 0c lea 0xc(%rsp),%rdx 615: be 03 00 00 00 mov $0x3,%esi 61a: bf 0a 00 00 00 mov $0xa,%edi 61f: e8 d6 ff ff ff callq 5fa <ex5> Question Identifique a partir dos tipos de dados colocados nos registradores qual o tipo dos argumentos da fun\u00e7\u00e3o. Question Qual s\u00e3o os endere\u00e7os passados para a fun\u00e7\u00e3o ex5 ? Escreva-os em fun\u00e7\u00e3o do registrador %rsp . Question Os endere\u00e7os acima s\u00e3o passados em quais registradores? Vamos agora ao c\u00f3digo de ex5 : 00000000000005fa <ex5>: 5fa: 89 f8 mov %edi,%eax 5fc: 48 89 d7 mov %rdx,%rdi 5ff: 99 cltd 600: f7 fe idiv %esi 602: 89 07 mov %eax,(%rdi) 604: 89 11 mov %edx,(%rcx) 606: c3 retq Question Como a instru\u00e7\u00e3o idiv funciona? Em quais registradores ela posiciona seu resultado? Em quais registradores ela espera a entrada? Question O qu\u00ea faz a instru\u00e7\u00e3o cltd ? Por qu\u00ea ela \u00e9 necess\u00e1ria? Question Fa\u00e7a a tradu\u00e7\u00e3o de ex5 para C .","title":"Arquivo ex5 (desafio)"},{"location":"aulas/06-condicionais/","text":"06 - Condicionais \u00b6 Express\u00f5es booleanas \u00b6 Vimos na expositiva que toda opera\u00e7\u00e3o aritm\u00e9tica preenche as flags CF , ZF , SF e OF e que podemos usar estas flags para montar express\u00f5es booleanas com as instru\u00e7\u00f5es set* . A tabela abaixo mostra as instru\u00e7\u00f5es respons\u00e1veis cada tipo de express\u00e3o booleana. Tamb\u00e9m vimos que podemos preencher estas flags usando as instru\u00e7\u00f5es cmp e test , que executam opera\u00e7\u00f5es aritm\u00e9ticas (subtra\u00e7\u00e3o e E bit a bit) mas n\u00e3o guardam o resultado. Vamos analisar o c\u00f3digo assembly da seguinte fun\u00e7\u00e3o: int igual ( int a , int b ) { return a == b ; } 0000000000000000 < igual > : 0: 39 f7 cmp %esi , %edi 2: 0 f 94 c0 sete %al 5: 0 f b6 c0 movzbl %al , %eax 8: c3 retq A compara\u00e7\u00e3o a == b \u00e9 feita primeiro executando cmp entre os argumentos %edi e %esi e depois usando sete ( set equal ) para atribuir 1 %al se %edi == %esi e 0 caso contr\u00e1rio. Por fim, temos a instru\u00e7\u00e3o movzbl , que faz o cast de char ( %al ) para int ( %eax ). Lembre-se que as instru\u00e7\u00f5es set* s\u00f3 modificam os primeiros 8 bits de %eax . O restante continua com o valor antigo. Usamos movzbl para extender o n\u00famero em %al para ocupar todo %eax . Tip As instru\u00e7\u00f5es de convers\u00e3o de tipos s\u00e3o bastante frequentes em Assembly, principalmente para expandir valores colocados em registradores menores para registradores maiores. Elas seguem a seguinte regra: MOVtsd t pode ser z para tipos unsigned (completando com **z**eros) e s para tipos signed (completando com o bit de **s**inal). s \u00e9 o tamanho do registrador fonte seguindo a nota\u00e7\u00e3o b para 1 byte, w para 2 bytes, l para 4 bytes e q para 8 bytes. d \u00e9 o tamanho do registrador destino, seguinto a mesma nota\u00e7\u00e3o acima. Por exemplo, a instru\u00e7\u00e3o MOVZWQ converte um unsigned short para um unsigned long . Convers\u00f5es de 4 para 8 bytes muitas vezes s\u00e3o feitas com a instru\u00e7\u00e3o cltq , que extende (com sinal) %eax para %rax . Uma boa refer\u00eancia \u00e9 este site da Oracle . Vamos agora praticar. Nos 3 exerc\u00edcios abaixo temos fun\u00e7\u00f5es que avaliam uma (ou mais) express\u00f5es booleanas entre seus argumentos e retornam o resultado. Arquivo ex1 \u00b6 Reconstrua a fun\u00e7\u00e3o ex1 a partir do c\u00f3digo assembly abaixo. 0000000000000000 < ex1 > : 0: 83 ff 0 a cmp $0xa , %edi 3: 0 f 9 f c0 setg %al 6: 0 f b6 c0 movzbl %al , %eax 9: c3 retq Question Qual \u00e9 o tamanho do argumento de ex1 ? Ele \u00e9 signed ou unsigned ? Example Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o com o professor ou com algum colega que j\u00e1 validou sua solu\u00e7\u00e3o. Arquivo ex2 \u00b6 Reconstrua a fun\u00e7\u00e3o ex2 a partir do c\u00f3digo assembly abaixo 0000000000000000 < ex2 > : 0: 48 39 f7 cmp %rsi , %rdi 3: 0 f 96 c0 setbe %al 6: 0 f b6 c0 movzbl %al , %eax 9: c3 retq Question Qual \u00e9 o tamanho dos argumentos de ex2 ? Ele \u00e9 signed ou unsigned ? Example Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o com o professor ou com algum colega que j\u00e1 validou sua solu\u00e7\u00e3o. Arquivo ex3 \u00b6 Reconstrua a fun\u00e7\u00e3o ex3 a partir do c\u00f3digo assembly abaixo. 0000000000000000 < ex3 > : 0: 48 39 f7 cmp %rsi , %rdi 3: 0 f 9 f c0 setg %al 6: 48 85 f6 test %rsi , %rsi 9: 0 f 9 f c2 setg %dl c: 21 d0 and %edx , %eax e: 0 f b6 c0 movzbl %al , %eax 11: c3 retq Question Qual \u00e9 o tamanho dos argumentos de ex3 ? Ele \u00e9 signed ou unsigned ? Example Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o com o professor ou com algum colega. Condicionais \u00b6 Vimos na segunda parte expositiva que Assembly possui apenas instru\u00e7\u00f5es de pulos condicionais ( j* onde * representa uma compara\u00e7\u00e3o usando as mesmas abrevia\u00e7\u00f5es de set* ) e n\u00e3o condicionais ( jmp ). Vimos tamb\u00e9m que a combina\u00e7\u00e3o destas instru\u00e7\u00f5es com cmp e test \u00e9 equivalente \u00e0 dupla de comandos if ( cond - booleana ) { goto label ; } A tabela abaixo mostra as opera\u00e7\u00f5es de saltos condicionais. {width=400px} Exemplo guiado \u00b6 Vamos agora fazer um exemplo guiado. Analisaremos o seguinte c\u00f3digo: 0000000000000000 < eh_par >: 0 : 40 f6 c7 01 test $ 0x1 , % dil 4 : 74 06 je c < eh_par + 0xc > 6 : b8 00 00 00 00 mov $ 0x0 , % eax b : c3 retq c : b8 01 00 00 00 mov $ 0x1 , % eax 11 : c3 retq Pares de instru\u00e7\u00f5es test-j* ou cmp-j* s\u00e3o comumente usadas para representar a constru\u00e7\u00e3o if-goto . O nome da fun\u00e7\u00e3o d\u00e1 uma dica de seu valor de retorno. Voc\u00ea consegue entender o porqu\u00ea test $1, %dil faz isto? \\vspace{5em} Vamos agora traduzir a fun\u00e7\u00e3o eh_par para gotoC . As linhas 0-4 s\u00e3o transformadas em um par if-goto . O restante s\u00e3o instru\u00e7\u00f5es que j\u00e1 conhecemos. int eh_par ( long a ) { if ( a & 1 == 0 ) goto if1 ; return 0 ; if1 : return 1 ; } Tiramos ent\u00e3o o goto e levando em conta sua resposta no item anterior, ficamos com o seguinte c\u00f3digo. Note que precisamos negar a compara\u00e7\u00e3o feita no c\u00f3digo anterior! int eh_par ( long a ) { if ( a % 2 != 0 ) { return 0 ; } return 1 ; } Podemos observar duas coisas no c\u00f3digo assembly gerado: O c\u00f3digo que estava dentro do if foi colocado ap\u00f3s o c\u00f3digo que estava fora do if! O compilador pode mudar a ordem dos nossos blocos de c\u00f3digo se for conveniente (para ele, n\u00e3o para n\u00f3s). A constru\u00e7\u00e3o test-j* e cmp-j* pode ser mapeada diretamente para if-goto . Por\u00e9m, reconstruir um c\u00f3digo leg\u00edvel requer, muitas vezes, mudar c\u00f3digo de lugar. Vamos agora praticar com alguns exerc\u00edcios simples: Arquivo ex4 \u00b6 Veja o c\u00f3digo abaixo 0000000000000000 < fun4 > : 0: 48 85 ff test %rdi , %rdi 3: 7 e 0 a jle f < fun4 + 0xf > 5: b8 02 00 00 00 mov $0x2 , %eax a: 48 0 f af c6 imul %rsi , %rax e: c3 retq f: b8 01 00 00 00 mov $0x1 , %eax 14: eb f4 jmp a < fun4 + 0xa > Question Qual express\u00e3o booleana \u00e9 testada? Example Fa\u00e7a a tradu\u00e7\u00e3o desta fun\u00e7\u00e3o para gotoC . Example Transforme o c\u00f3digo acima em C leg\u00edvel. Arquivo ex5 \u00b6 Veja o c\u00f3digo da fun\u00e7\u00e3o abaixo. 0000000000000000 < ex5 > : 0: 48 85 ff test %rdi , %rdi 3: 0 f 9 f c2 setg %dl 6: 48 85 f6 test %rsi , %rsi 9: 0 f 9 e c0 setle %al c: 84 c2 test %al , %dl e: 75 05 jne 15 < ex5 + 0x15 > 10: 48 8 d 46 fe lea - 0x2 ( %rsi ), %rax 14: c3 retq 15: 48 8 d 47 05 lea 0x5 ( %rdi ), %rax 19: c3 retq Question Qual s\u00e3o as express\u00f5es booleanas testadas? (Dica: s\u00e3o 3, assim como no exerc\u00edcio 3). Example Fa\u00e7a uma tradu\u00e7\u00e3o para gotoC . Example Transforme seu c\u00f3digo acima para C leg\u00edvel. Exemplo guiado II \u00b6 Veremos agora um exemplo if/else : int exemplo2 ( long a , long b ) { long c ; if ( a >= 5 && b <= 0 ) { c = a + b ; } else { c = a - b ; } return c ; } Seu assembly correspondente, quando compilado com gcc -Og -c \u00e9 0000000000000000 < exemplo2 > : 0: 48 83 ff 04 cmp $0x4 , %rdi 4: 0 f 9 f c2 setg %dl 7: 48 85 f6 test %rsi , %rsi a: 0 f 9 e c0 setle %al d: 84 c2 test %al , %dl f: 75 07 jne 18 < exemplo2 + 0x18 > 11: 48 89 f8 mov %rdi , %rax 14: 48 29 f0 sub %rsi , %rax 17: c3 retq 18: 48 8 d 04 37 lea ( %rdi , %rsi , 1 ), %rax 1 c: c3 retq Primeiramente, notamos que a fun\u00e7\u00e3o recebe dois argumentos (pois s\u00f3 utiliza %rdi e %rsi ) e que ambos s\u00e3o tratados como long . Vamos ent\u00e3o \u00e0s express\u00f5es booleanas. Existem tr\u00eas express\u00f5es boolenas: cmp - setg (linhas 0-4 ) compara %rdi com 4 e seta %dl=1 se %rdi>4 (**g**reater) test-setle (linhas 7-a ) compara %rsi com 0 e seta %al=1 se %rsi<=0 (**l**ess or **e**qual). test (linha d ) entre %dl e %al . O resultado n\u00e3o \u00e9 armazenado. Logo abaixo do \u00faltimo test temos um jne (linha f ), acr\u00f4nimo para **j**ump if **n**ot **e**qual. Ou seja, fazemos o jump se %dl && %al for verdadeiro. Logo em seguida temos instru\u00e7\u00f5es aritm\u00e9ticas, que j\u00e1 estudamos nos \u00faltimos handouts. Assim como vimos nos slides, vamos converter este c\u00f3digo para gotoC primeiro. Assim como fizemos nos exerc\u00edcios de 1 a 3, criaremos uma vari\u00e1vel para as express\u00f5es booleanas 1 e 2 e substituiremos as instru\u00e7\u00f5es test-jne (linhas d-f ) por um par if-goto . Veja abaixo: int exemplo2 ( long a , long b ) { long retval ; int expr1 = a > 4 ; int expr2 = b <= 0 ; if ( expr1 && expr2 ) goto if1 ; retval = a ; retval -= b ; return retval ; if1 : retval = a + b ; return retval ; } \\pagebreak Podemos ent\u00e3o melhorar tornar este c\u00f3digo mais leg\u00edvel, resultando no seguinte: int exemplo2 ( long a , long b ) { if ( a > 4 && b <= 0 ) { return a + b ; } else { return a - b ; } } Duas coisas importantes podem ser vistas neste c\u00f3digo As compara\u00e7\u00f5es n\u00e3o s\u00e3o exatamente iguais ( a>4 e a>=5 ), mas s\u00e3o equivalentes. O compilador pode trocar a ordem do if/else e colocar o else primeiro no Assembly gerado. Isto n\u00e3o altera o resultado da fun\u00e7\u00e3o, mas pode ser confuso de in\u00edcio. Arquivo ex6 \u00b6 O exerc\u00edcio abaixo usa if-else . 0000000000000000 < ex6 > : 0: 48 39 f7 cmp %rsi , %rdi 3: 7 e 03 jle 8 < ex6 + 0x8 > 5: 48 89 fe mov %rdi , %rsi 8: 48 85 ff test %rdi , %rdi b: 7 e 03 jle 10 < ex6 + 0x10 > d: 48 f7 de neg %rsi 10: 89 f0 mov %esi , %eax 12: c3 retq Example Traduza o c\u00f3digo acima para gotoC . Example Fa\u00e7a uma vers\u00e3o leg\u00edvel do c\u00f3digo acima.","title":"06 - Condicionais"},{"location":"aulas/06-condicionais/#06-condicionais","text":"","title":"06 - Condicionais"},{"location":"aulas/06-condicionais/#expressoes-booleanas","text":"Vimos na expositiva que toda opera\u00e7\u00e3o aritm\u00e9tica preenche as flags CF , ZF , SF e OF e que podemos usar estas flags para montar express\u00f5es booleanas com as instru\u00e7\u00f5es set* . A tabela abaixo mostra as instru\u00e7\u00f5es respons\u00e1veis cada tipo de express\u00e3o booleana. Tamb\u00e9m vimos que podemos preencher estas flags usando as instru\u00e7\u00f5es cmp e test , que executam opera\u00e7\u00f5es aritm\u00e9ticas (subtra\u00e7\u00e3o e E bit a bit) mas n\u00e3o guardam o resultado. Vamos analisar o c\u00f3digo assembly da seguinte fun\u00e7\u00e3o: int igual ( int a , int b ) { return a == b ; } 0000000000000000 < igual > : 0: 39 f7 cmp %esi , %edi 2: 0 f 94 c0 sete %al 5: 0 f b6 c0 movzbl %al , %eax 8: c3 retq A compara\u00e7\u00e3o a == b \u00e9 feita primeiro executando cmp entre os argumentos %edi e %esi e depois usando sete ( set equal ) para atribuir 1 %al se %edi == %esi e 0 caso contr\u00e1rio. Por fim, temos a instru\u00e7\u00e3o movzbl , que faz o cast de char ( %al ) para int ( %eax ). Lembre-se que as instru\u00e7\u00f5es set* s\u00f3 modificam os primeiros 8 bits de %eax . O restante continua com o valor antigo. Usamos movzbl para extender o n\u00famero em %al para ocupar todo %eax . Tip As instru\u00e7\u00f5es de convers\u00e3o de tipos s\u00e3o bastante frequentes em Assembly, principalmente para expandir valores colocados em registradores menores para registradores maiores. Elas seguem a seguinte regra: MOVtsd t pode ser z para tipos unsigned (completando com **z**eros) e s para tipos signed (completando com o bit de **s**inal). s \u00e9 o tamanho do registrador fonte seguindo a nota\u00e7\u00e3o b para 1 byte, w para 2 bytes, l para 4 bytes e q para 8 bytes. d \u00e9 o tamanho do registrador destino, seguinto a mesma nota\u00e7\u00e3o acima. Por exemplo, a instru\u00e7\u00e3o MOVZWQ converte um unsigned short para um unsigned long . Convers\u00f5es de 4 para 8 bytes muitas vezes s\u00e3o feitas com a instru\u00e7\u00e3o cltq , que extende (com sinal) %eax para %rax . Uma boa refer\u00eancia \u00e9 este site da Oracle . Vamos agora praticar. Nos 3 exerc\u00edcios abaixo temos fun\u00e7\u00f5es que avaliam uma (ou mais) express\u00f5es booleanas entre seus argumentos e retornam o resultado.","title":"Express\u00f5es booleanas"},{"location":"aulas/06-condicionais/#arquivo-ex1","text":"Reconstrua a fun\u00e7\u00e3o ex1 a partir do c\u00f3digo assembly abaixo. 0000000000000000 < ex1 > : 0: 83 ff 0 a cmp $0xa , %edi 3: 0 f 9 f c0 setg %al 6: 0 f b6 c0 movzbl %al , %eax 9: c3 retq Question Qual \u00e9 o tamanho do argumento de ex1 ? Ele \u00e9 signed ou unsigned ? Example Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o com o professor ou com algum colega que j\u00e1 validou sua solu\u00e7\u00e3o.","title":"Arquivo ex1"},{"location":"aulas/06-condicionais/#arquivo-ex2","text":"Reconstrua a fun\u00e7\u00e3o ex2 a partir do c\u00f3digo assembly abaixo 0000000000000000 < ex2 > : 0: 48 39 f7 cmp %rsi , %rdi 3: 0 f 96 c0 setbe %al 6: 0 f b6 c0 movzbl %al , %eax 9: c3 retq Question Qual \u00e9 o tamanho dos argumentos de ex2 ? Ele \u00e9 signed ou unsigned ? Example Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o com o professor ou com algum colega que j\u00e1 validou sua solu\u00e7\u00e3o.","title":"Arquivo ex2"},{"location":"aulas/06-condicionais/#arquivo-ex3","text":"Reconstrua a fun\u00e7\u00e3o ex3 a partir do c\u00f3digo assembly abaixo. 0000000000000000 < ex3 > : 0: 48 39 f7 cmp %rsi , %rdi 3: 0 f 9 f c0 setg %al 6: 48 85 f6 test %rsi , %rsi 9: 0 f 9 f c2 setg %dl c: 21 d0 and %edx , %eax e: 0 f b6 c0 movzbl %al , %eax 11: c3 retq Question Qual \u00e9 o tamanho dos argumentos de ex3 ? Ele \u00e9 signed ou unsigned ? Example Coloque sua tradu\u00e7\u00e3o abaixo. Valide sua solu\u00e7\u00e3o com o professor ou com algum colega.","title":"Arquivo ex3"},{"location":"aulas/06-condicionais/#condicionais","text":"Vimos na segunda parte expositiva que Assembly possui apenas instru\u00e7\u00f5es de pulos condicionais ( j* onde * representa uma compara\u00e7\u00e3o usando as mesmas abrevia\u00e7\u00f5es de set* ) e n\u00e3o condicionais ( jmp ). Vimos tamb\u00e9m que a combina\u00e7\u00e3o destas instru\u00e7\u00f5es com cmp e test \u00e9 equivalente \u00e0 dupla de comandos if ( cond - booleana ) { goto label ; } A tabela abaixo mostra as opera\u00e7\u00f5es de saltos condicionais. {width=400px}","title":"Condicionais"},{"location":"aulas/06-condicionais/#exemplo-guiado","text":"Vamos agora fazer um exemplo guiado. Analisaremos o seguinte c\u00f3digo: 0000000000000000 < eh_par >: 0 : 40 f6 c7 01 test $ 0x1 , % dil 4 : 74 06 je c < eh_par + 0xc > 6 : b8 00 00 00 00 mov $ 0x0 , % eax b : c3 retq c : b8 01 00 00 00 mov $ 0x1 , % eax 11 : c3 retq Pares de instru\u00e7\u00f5es test-j* ou cmp-j* s\u00e3o comumente usadas para representar a constru\u00e7\u00e3o if-goto . O nome da fun\u00e7\u00e3o d\u00e1 uma dica de seu valor de retorno. Voc\u00ea consegue entender o porqu\u00ea test $1, %dil faz isto? \\vspace{5em} Vamos agora traduzir a fun\u00e7\u00e3o eh_par para gotoC . As linhas 0-4 s\u00e3o transformadas em um par if-goto . O restante s\u00e3o instru\u00e7\u00f5es que j\u00e1 conhecemos. int eh_par ( long a ) { if ( a & 1 == 0 ) goto if1 ; return 0 ; if1 : return 1 ; } Tiramos ent\u00e3o o goto e levando em conta sua resposta no item anterior, ficamos com o seguinte c\u00f3digo. Note que precisamos negar a compara\u00e7\u00e3o feita no c\u00f3digo anterior! int eh_par ( long a ) { if ( a % 2 != 0 ) { return 0 ; } return 1 ; } Podemos observar duas coisas no c\u00f3digo assembly gerado: O c\u00f3digo que estava dentro do if foi colocado ap\u00f3s o c\u00f3digo que estava fora do if! O compilador pode mudar a ordem dos nossos blocos de c\u00f3digo se for conveniente (para ele, n\u00e3o para n\u00f3s). A constru\u00e7\u00e3o test-j* e cmp-j* pode ser mapeada diretamente para if-goto . Por\u00e9m, reconstruir um c\u00f3digo leg\u00edvel requer, muitas vezes, mudar c\u00f3digo de lugar. Vamos agora praticar com alguns exerc\u00edcios simples:","title":"Exemplo guiado"},{"location":"aulas/06-condicionais/#arquivo-ex4","text":"Veja o c\u00f3digo abaixo 0000000000000000 < fun4 > : 0: 48 85 ff test %rdi , %rdi 3: 7 e 0 a jle f < fun4 + 0xf > 5: b8 02 00 00 00 mov $0x2 , %eax a: 48 0 f af c6 imul %rsi , %rax e: c3 retq f: b8 01 00 00 00 mov $0x1 , %eax 14: eb f4 jmp a < fun4 + 0xa > Question Qual express\u00e3o booleana \u00e9 testada? Example Fa\u00e7a a tradu\u00e7\u00e3o desta fun\u00e7\u00e3o para gotoC . Example Transforme o c\u00f3digo acima em C leg\u00edvel.","title":"Arquivo ex4"},{"location":"aulas/06-condicionais/#arquivo-ex5","text":"Veja o c\u00f3digo da fun\u00e7\u00e3o abaixo. 0000000000000000 < ex5 > : 0: 48 85 ff test %rdi , %rdi 3: 0 f 9 f c2 setg %dl 6: 48 85 f6 test %rsi , %rsi 9: 0 f 9 e c0 setle %al c: 84 c2 test %al , %dl e: 75 05 jne 15 < ex5 + 0x15 > 10: 48 8 d 46 fe lea - 0x2 ( %rsi ), %rax 14: c3 retq 15: 48 8 d 47 05 lea 0x5 ( %rdi ), %rax 19: c3 retq Question Qual s\u00e3o as express\u00f5es booleanas testadas? (Dica: s\u00e3o 3, assim como no exerc\u00edcio 3). Example Fa\u00e7a uma tradu\u00e7\u00e3o para gotoC . Example Transforme seu c\u00f3digo acima para C leg\u00edvel.","title":"Arquivo ex5"},{"location":"aulas/06-condicionais/#exemplo-guiado-ii","text":"Veremos agora um exemplo if/else : int exemplo2 ( long a , long b ) { long c ; if ( a >= 5 && b <= 0 ) { c = a + b ; } else { c = a - b ; } return c ; } Seu assembly correspondente, quando compilado com gcc -Og -c \u00e9 0000000000000000 < exemplo2 > : 0: 48 83 ff 04 cmp $0x4 , %rdi 4: 0 f 9 f c2 setg %dl 7: 48 85 f6 test %rsi , %rsi a: 0 f 9 e c0 setle %al d: 84 c2 test %al , %dl f: 75 07 jne 18 < exemplo2 + 0x18 > 11: 48 89 f8 mov %rdi , %rax 14: 48 29 f0 sub %rsi , %rax 17: c3 retq 18: 48 8 d 04 37 lea ( %rdi , %rsi , 1 ), %rax 1 c: c3 retq Primeiramente, notamos que a fun\u00e7\u00e3o recebe dois argumentos (pois s\u00f3 utiliza %rdi e %rsi ) e que ambos s\u00e3o tratados como long . Vamos ent\u00e3o \u00e0s express\u00f5es booleanas. Existem tr\u00eas express\u00f5es boolenas: cmp - setg (linhas 0-4 ) compara %rdi com 4 e seta %dl=1 se %rdi>4 (**g**reater) test-setle (linhas 7-a ) compara %rsi com 0 e seta %al=1 se %rsi<=0 (**l**ess or **e**qual). test (linha d ) entre %dl e %al . O resultado n\u00e3o \u00e9 armazenado. Logo abaixo do \u00faltimo test temos um jne (linha f ), acr\u00f4nimo para **j**ump if **n**ot **e**qual. Ou seja, fazemos o jump se %dl && %al for verdadeiro. Logo em seguida temos instru\u00e7\u00f5es aritm\u00e9ticas, que j\u00e1 estudamos nos \u00faltimos handouts. Assim como vimos nos slides, vamos converter este c\u00f3digo para gotoC primeiro. Assim como fizemos nos exerc\u00edcios de 1 a 3, criaremos uma vari\u00e1vel para as express\u00f5es booleanas 1 e 2 e substituiremos as instru\u00e7\u00f5es test-jne (linhas d-f ) por um par if-goto . Veja abaixo: int exemplo2 ( long a , long b ) { long retval ; int expr1 = a > 4 ; int expr2 = b <= 0 ; if ( expr1 && expr2 ) goto if1 ; retval = a ; retval -= b ; return retval ; if1 : retval = a + b ; return retval ; } \\pagebreak Podemos ent\u00e3o melhorar tornar este c\u00f3digo mais leg\u00edvel, resultando no seguinte: int exemplo2 ( long a , long b ) { if ( a > 4 && b <= 0 ) { return a + b ; } else { return a - b ; } } Duas coisas importantes podem ser vistas neste c\u00f3digo As compara\u00e7\u00f5es n\u00e3o s\u00e3o exatamente iguais ( a>4 e a>=5 ), mas s\u00e3o equivalentes. O compilador pode trocar a ordem do if/else e colocar o else primeiro no Assembly gerado. Isto n\u00e3o altera o resultado da fun\u00e7\u00e3o, mas pode ser confuso de in\u00edcio.","title":"Exemplo guiado II"},{"location":"aulas/06-condicionais/#arquivo-ex6","text":"O exerc\u00edcio abaixo usa if-else . 0000000000000000 < ex6 > : 0: 48 39 f7 cmp %rsi , %rdi 3: 7 e 03 jle 8 < ex6 + 0x8 > 5: 48 89 fe mov %rdi , %rsi 8: 48 85 ff test %rdi , %rdi b: 7 e 03 jle 10 < ex6 + 0x10 > d: 48 f7 de neg %rsi 10: 89 f0 mov %esi , %eax 12: c3 retq Example Traduza o c\u00f3digo acima para gotoC . Example Fa\u00e7a uma vers\u00e3o leg\u00edvel do c\u00f3digo acima.","title":"Arquivo ex6"},{"location":"aulas/07-loops/","text":"07 - Loops \u00b6 Arquivo ex1.o \u00b6 Com base no c\u00f3digo assembly abaixo(arquivo ex1.o ) e responda os itens. Dump of assembler code for function soma_2n : 0 x066a <+ 0 > : mov $0x1 , %eax 0 x066f <+ 5 > : jmp 0x676 < soma_2n + 12 > 0 x0671 <+ 7 > : shr %edi 0 x0673 <+ 9 > : add $0x1 , %eax 0 x0676 <+ 12 > : cmp $0x1 , %edi 0 x0679 <+ 15 > : ja 0x671 < soma_2n + 7 > 0 x067b <+ 17 > : repz retq Question Localize no c\u00f3digo acima as instru\u00e7\u00f5es de saltos ( jmp ou condicionais j* ). Desenhe setas indicando para qual linha do c\u00f3digo elas pulam. Question Analise o fluxo de saltos do seu c\u00f3digo. Existe um loop? Entre quais linhas? Question Comece fazendo uma vers\u00e3o C usando somente if-goto Question Transforme a constru\u00e7\u00e3o que voc\u00ea fez acima em um c\u00f3digo usando while . Exerc\u00edcios para entrega \u00b6 Vamos agora exercitar o que vimos na aula expositiva. Os exerc\u00edcios abaixo est\u00e3o no reposit\u00f3rio de atividades e as perguntas no handout tem o objetivo de ajudar a compreender c\u00f3digo cada vez mais complexos. Arquivo ex2 \u00b6 Leia o c\u00f3digo assembly abaixo e responda. Dump of assembler code for function soma_n : 0 x066a <+ 0 > : mov $0x0 , %edx 0 x066f <+ 5 > : mov $0x0 , %eax 0 x0674 <+ 10 > : jmp 0x67f < soma_n + 21 > 0 x0676 <+ 12 > : movslq %edx , %rcx 0 x0679 <+ 15 > : add %rcx , %rax 0 x067c <+ 18 > : add $0x1 , %edx 0 x067f <+ 21 > : cmp %edi , %edx 0 x0681 <+ 23 > : jl 0x676 < soma_n + 12 > 0 x0683 <+ 25 > : repz retq Question Desenhe as flechas indicando o destino de cada instru\u00e7\u00e3o de pulo ( jmp ou j* ). Question Escreva abaixo o cabe\u00e7alho da fun\u00e7\u00e3o soma_n . Dica : procure por registradores que s\u00e3o lidos antes de serem escritos. Question Fa\u00e7a a tradu\u00e7\u00e3o do c\u00f3digo acima para C usando somente if-goto Question Converta o c\u00f3digo acima para uma vers\u00e3o leg\u00edvel em C . Arquivo ex3 \u00b6 Dump of assembler code for function ex5 : 0 x1139 <+ 0 > : mov $0x0 , %ecx 0 x113e <+ 5 > : mov $0x0 , %r8d 0 x1144 <+ 11 > : jmp 0x114a < ex4 + 17 > 0 x1146 <+ 13 > : add $0x1 , %rcx 0 x114a <+ 17 > : cmp %rdi , %rcx 0 x114d <+ 20 > : jge 0x1161 < ex4 + 40 > 0 x114f <+ 22 > : mov %rcx , %rax 0 x1152 <+ 25 > : cqto 0 x1154 <+ 27 > : idiv %rsi 0 x1157 <+ 30 > : test %rdx , %rdx 0 x115a <+ 33 > : jne 0x1146 < ex4 + 13 > 0 x115c <+ 35 > : add %rcx , %r8 0 x115f <+ 38 > : jmp 0x1146 < ex4 + 13 > 0 x1161 <+ 40 > : mov %r8 , %rax 0 x1164 <+ 43 > : retq Question Quantos argumentos a fun\u00e7\u00e3o acima recebe? Quais seus tipos? Dica : n\u00e3o se esque\u00e7a de buscar por registradores que s\u00e3o lidos antes de serem escritos. Question A fun\u00e7\u00e3o retorna algum valor? Se sim, qual seu tipo? Question A fun\u00e7\u00e3o acima combina loops e condicionais. Desenhe setas para onde as instru\u00e7\u00f5es de jmp apontam. Question Com base no exerc\u00edcio anterior, entre quais linhas o loop ocorre? E a condicional? Question O loop acima tem uma vari\u00e1vel contadora. Ela est\u00e1 em qual registrador? Qual seu tipo? Question Revise o funcionamento da instru\u00e7\u00e3o idiv . Em qual registrador \u00e9 armazenado o resultado da divis\u00e3o? E o resto? Question Qual a condi\u00e7\u00e3o testada na condicional? Question Escreva uma vers\u00e3o do c\u00f3digo acima usando somente if-goto . Question Escreva uma vers\u00e3o leg\u00edvel do c\u00f3digo acima.","title":"07 - Loops"},{"location":"aulas/07-loops/#07-loops","text":"","title":"07 - Loops"},{"location":"aulas/07-loops/#arquivo-ex1o","text":"Com base no c\u00f3digo assembly abaixo(arquivo ex1.o ) e responda os itens. Dump of assembler code for function soma_2n : 0 x066a <+ 0 > : mov $0x1 , %eax 0 x066f <+ 5 > : jmp 0x676 < soma_2n + 12 > 0 x0671 <+ 7 > : shr %edi 0 x0673 <+ 9 > : add $0x1 , %eax 0 x0676 <+ 12 > : cmp $0x1 , %edi 0 x0679 <+ 15 > : ja 0x671 < soma_2n + 7 > 0 x067b <+ 17 > : repz retq Question Localize no c\u00f3digo acima as instru\u00e7\u00f5es de saltos ( jmp ou condicionais j* ). Desenhe setas indicando para qual linha do c\u00f3digo elas pulam. Question Analise o fluxo de saltos do seu c\u00f3digo. Existe um loop? Entre quais linhas? Question Comece fazendo uma vers\u00e3o C usando somente if-goto Question Transforme a constru\u00e7\u00e3o que voc\u00ea fez acima em um c\u00f3digo usando while .","title":"Arquivo ex1.o"},{"location":"aulas/07-loops/#exercicios-para-entrega","text":"Vamos agora exercitar o que vimos na aula expositiva. Os exerc\u00edcios abaixo est\u00e3o no reposit\u00f3rio de atividades e as perguntas no handout tem o objetivo de ajudar a compreender c\u00f3digo cada vez mais complexos.","title":"Exerc\u00edcios para entrega"},{"location":"aulas/07-loops/#arquivo-ex2","text":"Leia o c\u00f3digo assembly abaixo e responda. Dump of assembler code for function soma_n : 0 x066a <+ 0 > : mov $0x0 , %edx 0 x066f <+ 5 > : mov $0x0 , %eax 0 x0674 <+ 10 > : jmp 0x67f < soma_n + 21 > 0 x0676 <+ 12 > : movslq %edx , %rcx 0 x0679 <+ 15 > : add %rcx , %rax 0 x067c <+ 18 > : add $0x1 , %edx 0 x067f <+ 21 > : cmp %edi , %edx 0 x0681 <+ 23 > : jl 0x676 < soma_n + 12 > 0 x0683 <+ 25 > : repz retq Question Desenhe as flechas indicando o destino de cada instru\u00e7\u00e3o de pulo ( jmp ou j* ). Question Escreva abaixo o cabe\u00e7alho da fun\u00e7\u00e3o soma_n . Dica : procure por registradores que s\u00e3o lidos antes de serem escritos. Question Fa\u00e7a a tradu\u00e7\u00e3o do c\u00f3digo acima para C usando somente if-goto Question Converta o c\u00f3digo acima para uma vers\u00e3o leg\u00edvel em C .","title":"Arquivo ex2"},{"location":"aulas/07-loops/#arquivo-ex3","text":"Dump of assembler code for function ex5 : 0 x1139 <+ 0 > : mov $0x0 , %ecx 0 x113e <+ 5 > : mov $0x0 , %r8d 0 x1144 <+ 11 > : jmp 0x114a < ex4 + 17 > 0 x1146 <+ 13 > : add $0x1 , %rcx 0 x114a <+ 17 > : cmp %rdi , %rcx 0 x114d <+ 20 > : jge 0x1161 < ex4 + 40 > 0 x114f <+ 22 > : mov %rcx , %rax 0 x1152 <+ 25 > : cqto 0 x1154 <+ 27 > : idiv %rsi 0 x1157 <+ 30 > : test %rdx , %rdx 0 x115a <+ 33 > : jne 0x1146 < ex4 + 13 > 0 x115c <+ 35 > : add %rcx , %r8 0 x115f <+ 38 > : jmp 0x1146 < ex4 + 13 > 0 x1161 <+ 40 > : mov %r8 , %rax 0 x1164 <+ 43 > : retq Question Quantos argumentos a fun\u00e7\u00e3o acima recebe? Quais seus tipos? Dica : n\u00e3o se esque\u00e7a de buscar por registradores que s\u00e3o lidos antes de serem escritos. Question A fun\u00e7\u00e3o retorna algum valor? Se sim, qual seu tipo? Question A fun\u00e7\u00e3o acima combina loops e condicionais. Desenhe setas para onde as instru\u00e7\u00f5es de jmp apontam. Question Com base no exerc\u00edcio anterior, entre quais linhas o loop ocorre? E a condicional? Question O loop acima tem uma vari\u00e1vel contadora. Ela est\u00e1 em qual registrador? Qual seu tipo? Question Revise o funcionamento da instru\u00e7\u00e3o idiv . Em qual registrador \u00e9 armazenado o resultado da divis\u00e3o? E o resto? Question Qual a condi\u00e7\u00e3o testada na condicional? Question Escreva uma vers\u00e3o do c\u00f3digo acima usando somente if-goto . Question Escreva uma vers\u00e3o leg\u00edvel do c\u00f3digo acima.","title":"Arquivo ex3"}]}